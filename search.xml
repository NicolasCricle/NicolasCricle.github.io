<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django QuerySet</title>
    <url>/2019/09/02/Django-%E4%B8%AD%E7%9A%84first/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Django ORM用到三个类：分别是：Manager、QuerySet、Model。</p>
<p>Manager：定义表级方法（表级方法就是影响一条或多条记录的方法），我们可以以models.Manager为父类，定义自己的manager，增加表级方法；</p>
<p>QuerySet：Manager类的一些方法会返回QuerySet实例，QuerySet是一个可遍历结构，包含一个或多个元素，每个元素都是一个Model 实例，它里面的方法也是表级方法，前面说了，Django给我们提供了增加表级方法的途径，那就是自定义manager类，而不是自定义QuerySet类，一般的我们没有自定义QuerySet类的必要；</p>
<p>models：模块中的Model类，我们定义表的model时，就是继承它，它的功能很强大，通过自定义model的instance可以获取外键实体等，它的方法都是记录级方法（都是实例方法，貌似无类方法），不要在里面定义类方法，比如计算记录的总数，查看所有记录，这些应该放在自定义的manager类中。以Django1.6为基础。</p>
<a id="more"></a>

<h1 id="QuerySet简介"><a href="#QuerySet简介" class="headerlink" title="QuerySet简介"></a>QuerySet简介</h1><p>QuerySet有两种来源：通过manager的方法得到，或者是通过QuerySet的方法得到。</p>
<p>mananger的方法和QuerySet的方法大部分同名，同意思，如filter(),update()等，但也有些不同，如manager有create()、get_or_create()，而QuerySet有delete()等，看源码就可以很容易的清楚Manager类与Queryset类的关系，Manager类的绝大部分方法是基于Queryset的。一个QuerySet包含一个或多个model instance。QuerySet类似于Python中的list，list的一些方法QuerySet也有，比如切片，遍历。</p>
<p><img src="/images/content/managerOrQuerySet.PNG" alt="manager or QuerySet"></p>
<p>QuerySet具有惰性加载的特性。只有当用到这个QuerySet时，才会查询数据库求值。另外，查询到的QuerySet又是缓存的，当再次使用同一个QuerySet时，并不会再查询数据库，而是直接从缓存获取。QuerySet也是可以参与运算的，运算的结果一般是QuerySet，当然也可能是QuerySet的子集（非求值运算）。当对一个QuerySet进行求值运算的时候，这个时候才会去查询数据库</p>
<h2 id="几种运算"><a href="#几种运算" class="headerlink" title="几种运算"></a>几种运算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUser</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">"名称"</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    score = models.IntegerField(verbose_name=<span class="string">"分数"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">"users"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    number = models.IntegerField(verbose_name=<span class="string">"组号"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="遍历运算"><a href="#遍历运算" class="headerlink" title="遍历运算"></a>遍历运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users = MyUser.objects.all()</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">    print(user)</span><br></pre></td></tr></table></figure>
<p>循环开始的时候，执行QuerySet，从数据库中查询，类似于原始的SQL语句SELECT * FROM users</p>
<h3 id="切片运算"><a href="#切片运算" class="headerlink" title="切片运算"></a>切片运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users = MyUser.objects.all()</span><br><span class="line">firstUser = users[:<span class="number">1</span>]</span><br><span class="line">type(firstUser)</span><br><span class="line"><span class="comment"># &lt;class 'django.db.models.query.QuerySet'&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于QuerySet切片运算出来的还是QuerySet，这个时候不会去数据库执行真正的查询<br>值得注意的是，对于QuerySet的切片操作不支持负数，也就是说不能出现[-2:-1]这样的切片方式，否则会直接抛出异常</p>
<h4 id="循环和切片的探究"><a href="#循环和切片的探究" class="headerlink" title="循环和切片的探究"></a>循环和切片的探究</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django&gt;db&gt;model&gt;query&gt;QuerySet</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">    <span class="string">"""Retrieve an item or slice from the set of results."""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(k, (int, slice)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError</span><br><span class="line">    <span class="keyword">assert</span> ((<span class="keyword">not</span> isinstance(k, slice) <span class="keyword">and</span> (k &gt;= <span class="number">0</span>)) <span class="keyword">or</span></span><br><span class="line">            (isinstance(k, slice) <span class="keyword">and</span> (k.start <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k.start &gt;= <span class="number">0</span>) <span class="keyword">and</span></span><br><span class="line">                (k.stop <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k.stop &gt;= <span class="number">0</span>))), \</span><br><span class="line">        <span class="string">"Negative indexing is not supported."</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._result_cache <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> self._result_cache[k]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(k, slice):</span><br><span class="line">        qs = self._chain()</span><br><span class="line">        <span class="keyword">if</span> k.start <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            start = int(k.start)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> k.stop <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stop = int(k.stop)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stop = <span class="literal">None</span></span><br><span class="line">        qs.query.set_limits(start, stop)          </span><br><span class="line">        <span class="keyword">return</span> list(qs)[::k.step] <span class="keyword">if</span> k.step <span class="keyword">else</span> qs</span><br><span class="line"></span><br><span class="line">    qs = self._chain()</span><br><span class="line">    qs.query.set_limits(k, k + <span class="number">1</span>)           <span class="comment"># query 的set_limits()</span></span><br><span class="line">    qs._fetch_all()</span><br><span class="line">    <span class="keyword">return</span> qs._result_cache[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>如果要使得python中的某一个object具有切片的功能，只需要实现<strong>getitem</strong>()方法就行了，通过观察Django的QuerySet源码部分，可以知道它对于切片的实现实际就是sql中的limit<br>同时,实现了<strong>getitem</strong>()后，该object也能够被for循环迭代</p>
<h3 id="获取QuerySet长度"><a href="#获取QuerySet长度" class="headerlink" title="获取QuerySet长度"></a>获取QuerySet长度</h3><p>获取一个QuerySet长度一般有两种办法，使用len()函数，或者使用count()执行方法<br>在Django的官方文档上，建议我们能使用的是count()执行函数，而不是使用len()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># django&gt;db&gt;model&gt;query&gt;QuerySet</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._fetch_all()</span><br><span class="line">    <span class="keyword">return</span> len(self._result_cache)</span><br></pre></td></tr></table></figure>
<p>原因在于QuerySet实现的len函数是首先将所有的数据都查出来，然后求数据列表长度<br>而使用count()执行方法，则相当于执行sql中的count，速度要比查数据快很多</p>
<h3 id="判断QuerySet是否为空"><a href="#判断QuerySet是否为空" class="headerlink" title="判断QuerySet是否为空"></a>判断QuerySet是否为空</h3><p>判断一个QuerySet也有多种方式。使用bool、使用exists()执行方法或者使用count()执行方法<br>bool是官方不推荐的，原因同上，而使用exists()是要比count()快一些的</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的动态属性</title>
    <url>/2020/02/27/Python%20%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>在Python中，数据的属性和处理数据的方法统称为 <strong>属性（attribute）</strong>。其实相对来说，方法只是可调用的属性。<br>除此之外，Python还可以创建特性，使用读值方法和取值方法修改数据的属性。<br>当使用 . 访问属性（obj.attr）的时候，当属性不存在的时候，会调用__getattr__方法即时计算属性的值。<br>由于Python中存在__setattr__以及__getattr__的方法，我们可以动态的创建属性。</p>
<a id="more"></a>

<h2 id="使用动态属性访问Json数据"><a href="#使用动态属性访问Json数据" class="headerlink" title="使用动态属性访问Json数据"></a>使用动态属性访问Json数据</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例数据 mj.json</span></span><br><span class="line">&#123; <span class="attr">"Schedule"</span>: </span><br><span class="line">  &#123; <span class="attr">"conferences"</span>: [&#123;<span class="attr">"serial"</span>: <span class="number">115</span> &#125;],</span><br><span class="line">    <span class="attr">"events"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">34505</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Why Schools Don´t Use Open Source to Teach Programming"</span>,</span><br><span class="line">        <span class="attr">"event_type"</span>: <span class="string">"40-minute conference session"</span>,</span><br><span class="line">        <span class="attr">"time_start"</span>: <span class="string">"2014-07-23 11:30:00"</span>,</span><br><span class="line">        <span class="attr">"time_stop"</span>: <span class="string">"2014-07-23 12:10:00"</span>,</span><br><span class="line">        <span class="attr">"venue_serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"Aside from the fact that high school programming..."</span>,</span><br><span class="line">        <span class="attr">"website_url"</span>: <span class="string">"http://oscon.com/oscon2014/public/schedule/detail/34505"</span>, </span><br><span class="line">        <span class="attr">"speakers"</span>: [<span class="number">157509</span>],</span><br><span class="line">        <span class="attr">"categories"</span>: [<span class="string">"Education"</span>] &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"speakers"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">157509</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Robert Lefkowitz"</span>,</span><br><span class="line">        <span class="attr">"photo"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://sharewave.com/"</span>,</span><br><span class="line">        <span class="attr">"position"</span>: <span class="string">"CTO"</span>,</span><br><span class="line">        <span class="attr">"affiliation"</span>: <span class="string">"Sharewave"</span>,</span><br><span class="line">        <span class="attr">"twitter"</span>: <span class="string">"sharewaveteam"</span>,</span><br><span class="line">        <span class="attr">"bio"</span>: <span class="string">"Robert ´r0ml´ Lefkowitz is the CTO at Sharewave, a startup..."</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"venues"</span>: [</span><br><span class="line">      &#123; <span class="attr">"serial"</span>: <span class="number">1462</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"F151"</span>,</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"Conference Venues"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'mj.json'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    rawData = json.load(fp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJson</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapData)</span>:</span></span><br><span class="line">        self._data = dict()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapData.items():</span><br><span class="line">            <span class="keyword">if</span> keyword.iskeyword(key):</span><br><span class="line">                key += <span class="string">"_"</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> key.isidentifier():</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            </span><br><span class="line">            self._data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        当使用点操作符访问属性的时候，如果没有找到，就会访问__getattr__方法</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self._data, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self._data, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.build(self._data[name])</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(cls, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, abc.Mapping):</span><br><span class="line">            <span class="keyword">return</span> cls(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, abc.MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls.build(item) <span class="keyword">for</span> item <span class="keyword">in</span> obj]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fj = FrozenJson(rawData)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fj</span><br><span class="line">Why Schools Don´t Use Open Source to Teach Programming</span><br></pre></td></tr></table></figure>
<ul>
<li>rawData 从指定的位置获取json数据，即</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>动态属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Python运算符重载</title>
    <url>/2020/02/07/Python%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="Python运算符重载的限制"><a href="#Python运算符重载的限制" class="headerlink" title="Python运算符重载的限制"></a>Python运算符重载的限制</h2><p>合适的运用运算符重载，能够让你的代码看起来整洁、可读性强。然而，不分场合不分地点的重载运算符，则会是一场灾难。<br>Python对于运算符重载做了一些限制，以平衡其灵活性、安全性以及可用性。 </p>
<a id="more"></a>
<ul>
<li>不能重载内置数据类型的运算符  </li>
<li>不能新建运算符，只能重载现有的  </li>
<li>某些运算符无法进行重载，例如 <strong>is or and not</strong></li>
</ul>
<h2 id="一元运算符的重载"><a href="#一元运算符的重载" class="headerlink" title="一元运算符的重载"></a>一元运算符的重载</h2><h3 id="一元运算符介绍"><a href="#一元运算符介绍" class="headerlink" title="一元运算符介绍"></a>一元运算符介绍</h3><p>在Python中 常见的一元运算符是 <strong>+</strong> 以及 <strong>-</strong>，除此之外，还有一个不多见的一元运算符 <strong>~</strong></p>
<blockquote>
<p><strong>~</strong> 运算符称之为 位非运算，其定义是将每个二进制取反，详细算法可以自行google，简单的记忆方法为：假如A为整数 ~A == -(A+1)</p>
</blockquote>
<blockquote>
<p><strong>+</strong> 运算符 通常情况下 +A == A总是成立的</p>
</blockquote>
<blockquote>
<p><strong>-</strong> 运算符 取负算术运算符 如果A是-1 则 -A == 1</p>
</blockquote>
<h3 id="对应的特殊方法名称"><a href="#对应的特殊方法名称" class="headerlink" title="对应的特殊方法名称"></a>对应的特殊方法名称</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>特殊方法</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>__neg__</td>
</tr>
<tr>
<td>-</td>
<td>__pos__</td>
</tr>
<tr>
<td>~</td>
<td>__invert__</td>
</tr>
</tbody></table>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>支持一元运算符很简单，只需要实现相应的特殊方法就行了，并且这几个特殊方法都只有一个参数 <strong>self</strong>，<br>但是要遵循运算符的一个基本法则：始终返还一个新的对象</p>
<p>为了方便说明接下来的运算符重载，定义一个新的数据类型—向量，实现其基本代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">		self.x = x</span><br><span class="line">		self.y = y</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)"</span>.format(self.__class__.__name__, *self)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> (item <span class="keyword">for</span> item <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> math.sqrt(sum(x*x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br></pre></td></tr></table></figure>
<p>需要向量数据结构达到下面的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>-v</span><br><span class="line">Vector(<span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+v</span><br><span class="line">Vector(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+v <span class="keyword">is</span> v				<span class="comment"># 返还的是一个新的对象</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>为Vector类添加特殊方法,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span></span><br><span class="line">	cls = type(self)</span><br><span class="line">	<span class="keyword">return</span> cls(*self)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span></span><br><span class="line">	cls = type(self)</span><br><span class="line">	<span class="keyword">return</span> cls(*(-item <span class="keyword">for</span> item <span class="keyword">in</span> self))</span><br></pre></td></tr></table></figure>
<p>对Vector类来说，已经实现了<strong>iter</strong>方法，并且在其中将构造Vector的数据全部返还，所以在新增的特殊方法中，直接对其使用拆包</p>
<h2 id="中缀运算符的重载"><a href="#中缀运算符的重载" class="headerlink" title="中缀运算符的重载"></a>中缀运算符的重载</h2><ul>
<li>中缀运算符 与之前一元运算符+不同，这里的+表示两个对象相加，而不是取正<br>向量加法定义中说明：两个向量可以叠加成一个新的向量。它的各个分量是两个相应向量的对应分量之和</li>
</ul>
<h3 id="涉及到的相应地特殊方法"><a href="#涉及到的相应地特殊方法" class="headerlink" title="涉及到的相应地特殊方法"></a>涉及到的相应地特殊方法</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>特殊方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>self + other</td>
<td>__add__</td>
<td>左分派</td>
</tr>
<tr>
<td>other + self</td>
<td>__radd__</td>
<td>右分派（后备机制）</td>
</tr>
</tbody></table>
<h3 id="使用-add-以及-radd-计算-a-b-的流程图"><a href="#使用-add-以及-radd-计算-a-b-的流程图" class="headerlink" title="使用__add__以及__radd__计算 a + b 的流程图"></a>使用__add__以及__radd__计算 a + b 的流程图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[a+b]--&gt;B&#123;a有__add__&#125;</span><br><span class="line">    B--Yes--&gt;C[获取a.__add__的结果]</span><br><span class="line">    C--&gt;D&#123;NotImplemented&#125;</span><br><span class="line">    D--No--&gt;E[返回结果]</span><br><span class="line">    D--Yes--&gt;F&#123;b有__radd__&#125;</span><br><span class="line">    B--No--&gt;F</span><br><span class="line">    F--&gt;G[获取b.__radd__的结果]</span><br><span class="line">    G--&gt;H&#123;NotInplemented&#125;</span><br><span class="line">    H--NO--&gt;E</span><br><span class="line">    H--Yes--&gt;I[抛出TypeError]</span><br><span class="line">    F--No--&gt;I</span><br></pre></td></tr></table></figure>
<p>__radd__是__add__的反向版本，是一种后背的机制，如果左操作数没有实现__add__方法，或者说实现了但是返还的是NotImplemented，那么Python解释器就会调用右操作数的__radd__方法来执行此次的+运算。</p>
<blockquote>
<p>NotImplemented 和 NotImplementedError<br>前者是特殊的一个单例值，当中缀运算符特殊方法不能处理给定的操作数的时候，就要把它返回。<br>后者是一种异常，一般由抽象类中的占位方法直接抛出，提醒子类必须覆盖。</p>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">	cls = type(self)</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> cls(*(x+y <span class="keyword">for</span> x, y <span class="keyword">in</span>  zip(self, other)))</span><br><span class="line">	<span class="keyword">except</span> TypeError:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> self + other</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">对于 \_\_add\_\_来说,将左操作对象与右操作对象 各位叠加，然后生成一个新的Vector返还  </span><br><span class="line">而对于\_\_radd\_\_而言，a + b 本来触动的是 右操作数b的 \_\_radd\_\_方法，在这个方法实现里直接将a, b调换，从而执行 b + a 运算。  </span><br><span class="line">如果other对象是不可迭代的，zip函数会返回TypeError错误，这里将其捕捉，然后统一返回指定错误<span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">&gt; zip函数  </span><br><span class="line">&gt; 使用zip函数可以轻松的并行迭代两个或多个可迭代对象，当其中任意一个迭代对象迭代终止的时候，zip函数立即停止，而不会发出警告  </span><br><span class="line">&gt; \&gt;&gt;&gt;a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    </span><br><span class="line">&gt; \&gt;&gt;&gt;b = (<span class="number">5</span>, <span class="number">6</span>)  </span><br><span class="line">&gt; \&gt;&gt;&gt;list(zip(a, b, fillvalue=<span class="number">0</span>))  </span><br><span class="line">&gt; [(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>)]  </span><br><span class="line">&gt; itertools包中有一个zip\_longest函数，可以设置迭代缺失值  **fillvalue**  </span><br><span class="line">&gt;  \&gt;&gt;&gt;<span class="keyword">import</span> itertools  </span><br><span class="line">&gt;  \&gt;&gt;&gt;functools.zip_longest(a, b, fillvalue=<span class="number">0</span>)  </span><br><span class="line">&gt; [(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 其余的中缀运算符</span></span><br><span class="line">|  运算符   | 正向方法  | 反向方法 | 就地方法 | 说明 |</span><br><span class="line">|  ----  | ----  | ---- | ---- | ---- | ---- |</span><br><span class="line">| + | \_\_add\_\_ | \_\_radd\_\_ | \_\_iadd\_\_ | 加法或者拼接 |</span><br><span class="line">| - | \_\_sub\_\_ | \_\_rsub\_\_ | \_\_isub\_\_ | 减法 |</span><br><span class="line">| * | \_\_mul\_\_ | \_\_rmul\_\_ | \_\_imul\_\_ | 乘法 | </span><br><span class="line">| / | \_\_truediv\_\_ | \_\_rturediv\_\_ | \_\_iturediv\_\_ | 除法 |</span><br><span class="line">| // | \_\_floordiv\_\_ | \_\_rfloordiv\_\_ | \_\_floordiv\_\_ | 整除、地板除 |</span><br><span class="line">| % | \_\_mod\_\_ | \_\_rmod\_\_ | \_\_imod\_\_ | 取模 |</span><br><span class="line">| divmod() | \_\_divmod\_\_ | \_\_rdivmod\_\_ | \_\_idivmod\_\_ | 返回由整除的商和模数构成的元祖 |</span><br><span class="line">| ** pow() | \_\_pow\_\_ | \_\_rpow\_\_ | \_\_ipow\_\_ | 幂运算 |</span><br><span class="line">| &amp; | \_\_and\_\_ | \_\_rand\_\_ | \_\_iand\_\_ | 位与运算 |</span><br><span class="line">| \| | \_\_or\_\_ | \_\_ror\_\_ | \_\_ior\_\_ | 位或运算 |</span><br><span class="line">| ^ | \_\_xor\_\_ | \_\_rxor\_\_ | \_\_ixor\_\_ | 位 异或运算 |</span><br><span class="line">| &lt;&lt; | \_\_lshift\_\_ | \_\_rlshift\_\_ | \_\_ilshift\_\_ | 按位左移 |</span><br><span class="line">| &gt;&gt; | \_\_rshift\_\_ | \_\_rrshift\_\_ | \_\_irshift\_\_ | 按位右移 |</span><br><span class="line">| @ | \_\_matmul\_\_ | \_\_rmatmul\_\_ | \_\_imatmul\_\_ | 矩阵乘法（<span class="number">3.5</span>以后Python版本支持） |</span><br><span class="line"></span><br><span class="line"><span class="comment">## 比较运算符的重载</span></span><br><span class="line">在Python中，常见的比较运算符有 **== 、!=、 &gt;、 &lt;、 &gt;=、 &lt;=**。  </span><br><span class="line">对于这些运算符的处理流程与之前的中缀运算符类似，但是也有两个重大的区别：  </span><br><span class="line"></span><br><span class="line">* 正向和反向调用使用的是**一个系列**的方法，比如对于 == 而言，正向调用和反向调用都是用的是 \_\_eq\_\_ 方法， 区别在于参数对调；而 &gt; 的正向调用是  &lt; 的反向调用 \_\_gt\_\_, 反向调用时 &lt; 的正向调用 \_\_lt\_\_。</span><br><span class="line">* 对于 == 以及 != 而言，反向调用失败后并不会直接抛出TypeError， 而是比较对象的ID。  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 涉及到的方法</span></span><br><span class="line">|  运算符   | 特殊方法  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| == | \_\_eq\_\_ |</span><br><span class="line"></span><br><span class="line"><span class="comment">### 代码实现</span></span><br><span class="line">需要达到的效果示下  </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector(<span class="number">1</span>, <span class="number">2</span>) == Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector(<span class="number">1</span>, <span class="number">2</span>) == Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> tuple(self) == tuple(other)</span><br></pre></td></tr></table></figure>
<p>简单的方法如上，直接按照向量相等的比较规则定义，比较向量的两个分量的大小。<br>但是也会出现如下BUG</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector(<span class="number">1</span>, <span class="number">2</span>) == (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>为防止出现上述问题，可以下改一下__eq__函数，加上类型限定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, Vector):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">	<span class="keyword">return</span> tuple(self) == tuple(other)</span><br></pre></td></tr></table></figure>
<h3 id="其余的比较运算符"><a href="#其余的比较运算符" class="headerlink" title="其余的比较运算符"></a>其余的比较运算符</h3><p>|  运算符   | 正向方法调用  | 反向方法调用 | 后备机制 |<br>|  —-  | —-  | —- | —- | —- |<br>| a==b | a.__eq__(b) | b.__eq__(a) | id(a) == id(b) |<br>| a!=b | a.__ne__(b) | b.__ne__(a) | not (a == b) |<br>| a&gt;b | a.__gt__(b) | b.__lt__(a) | 抛出TypeError |<br>| a&lt;b | a.__lt__(b) | b.__gt__(a) | 抛出TypeError |<br>| a&gt;=b | a.__ge__(b) | b.__le__(a) | 抛出TypeError |<br>| a&lt;=b | a.__le__(b) | b.__ge__(a) | 抛出TypeError |</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 上下文管理</title>
    <url>/2020/03/17/Python%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="if之外的else"><a href="#if之外的else" class="headerlink" title="if之外的else"></a>if之外的else</h2><p>在Python中，else子句不仅仅能在if语句中使用，还能在try、for、while语句中使用。<br>for/else、try/else、while/else的语言关系比较像，但是这些都和if/else差别和大，具体的行为如下解释。</p>
<a id="more"></a>

<blockquote>
<p>除了if/else之外，else在其他语句中的含义更像是单词“then”，表示完成之后再做这件事情。</p>
</blockquote>
<h3 id="for-else"><a href="#for-else" class="headerlink" title="for/else"></a>for/else</h3><p>当for循环完整运行结束的时候，即for循环没有被break语句中止，才会运行else语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">"aabbccdd"</span>:</span><br><span class="line">	<span class="keyword">if</span> item == <span class="string">"a"</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">"1ok!"</span>)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">"aabbccdd"</span>:</span><br><span class="line">	<span class="keyword">if</span> item == <span class="string">"a"</span>:</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">"2ok!"</span>)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="string">"aabbccdd"</span>:</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">"3ok!"</span>)</span><br></pre></td></tr></table></figure>
<p>第二个和第三个的for循环都是可以触法else的字语句的，而第一个for循环由于被break关键字打断，所以else不会被触法。</p>
<h3 id="while-else"><a href="#while-else" class="headerlink" title="while/else"></a>while/else</h3><p>仅当while循环因为条件为假值而退出的时候，即没有被break语句打断，才会运行else语句。</p>
<h3 id="try-else"><a href="#try-else" class="headerlink" title="try/else"></a>try/else</h3><p>当try语句块中没有异常抛出的时候才会运行esle语句块，并且，else语句块中抛出的异常不会被前面的except语句处理。<br>通常情况下，我们会这样描述try语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	dangerous_call()</span><br><span class="line">	after_call()</span><br><span class="line"><span class="keyword">except</span> SmaeError:</span><br><span class="line">	handler_error()</span><br></pre></td></tr></table></figure>
<p>但是为了更准确以及更加清晰，try语句块中应该只抛出预期的异常错误，而对于after_call()应该是当dangerous_call()没有出现异常的时候才去执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	dangerous_call()</span><br><span class="line"><span class="keyword">except</span> SmaeError:</span><br><span class="line">	handler_error()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	after_call()</span><br></pre></td></tr></table></figure>

<h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p>上下文管理器协议包含__enter__以及__exit__两个方法。with语句开始执行的时候，会在上下文管理器对象上调用__enter__方法，而当with语句结束的时候，__exit__也会被上下文管理对象来执行，用于处理可能出现的异常。</p>
<blockquote>
<p>和迭代器的存在是为了管理for语句一样，上下文管理器的存在目的是管理with语句。<br>with语句的目的是简化try/finally模式。用于保证一段代码运行完毕后执行某项操作。即便那段代码由于异常、&gt;  return语句或者sys.exit()调用而终止，也会执行指定的操作。<br>finally子句中的代码通常用于释放重要的资源，或者还原临时变更的状态。 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">WithTest</span>:</span></span><br><span class="line">···		<span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">···			print(<span class="string">"enter"</span>)</span><br><span class="line">···		</span><br><span class="line">···		<span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">···			print(<span class="string">"exit"</span>)</span><br><span class="line">		</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> WithTest():</span><br><span class="line">···		print(<span class="string">"doing sth!"</span>)</span><br><span class="line">···</span><br><span class="line">enter</span><br><span class="line">doing sth!</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>当上下文管理器对象的__enter__并没有实际返回值的时候，是可以不需要as子句的。<br>在with语句的时候，as子句的作用就是将__enter__的返回值绑定到as子句后面的变量上。</p>
<h3 id="enter-和-exit"><a href="#enter-和-exit" class="headerlink" title="__enter__和__exit__"></a>__enter__和__exit__</h3><p>解释器在调用__enter__方法的时候，除了隐形的self，不会传入任何参数。然而在调用<strong>exit</strong>的时候，除了self之外，会传递三个参数：<strong>exc_type</strong>、<strong>exc_value</strong>、<strong>traceback</strong>。</p>
<ul>
<li>exc_type:    异常类，如TypeError。</li>
<li>exc_value:    异常的实例，有时候会有参数传给异常构造方法，例如错误的消息，这些参数可以使用exc_value.args获取。</li>
<li>traceback：    traceback对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">        print(exc_type)</span><br><span class="line">        print(exc_value)</span><br><span class="line">        print(traceback)</span><br><span class="line">        print(exc_value.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> WithTest():</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"error"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="string">""" 输出结果</span></span><br><span class="line"><span class="string">&lt;class 'Exception'&gt;</span></span><br><span class="line"><span class="string">error</span></span><br><span class="line"><span class="string">&lt;traceback object at 0x1008b7ac8&gt;</span></span><br><span class="line"><span class="string">('error',)</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "/Users/livis/Desktop/notes/format_demo.py", line 55, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    raise Exception("error")</span></span><br><span class="line"><span class="string">Exception: error</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h2 id="contextmanager装饰器"><a href="#contextmanager装饰器" class="headerlink" title="contextmanager装饰器"></a>contextmanager装饰器</h2><p>使用@contextmanager可以方便的创建由生成器函数构成的上下文管理器对象，可以极大的减少样本代码量。<br>在使用了@contextmanager装饰的生成器中，yield关键字是把函数的定义体分成两个部分，yield之前的部分就相当于__enter__方法执行的内容，而yield之后的部分就相当于__exit__方法执行的内容。而yield的内容就是__enter__返还的，可以使用as子语句绑定的返回对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contenx_test</span><span class="params">(mystr)</span>:</span></span><br><span class="line">	print(<span class="string">"before enter!"</span>)</span><br><span class="line">	error = <span class="literal">None</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">	    <span class="keyword">yield</span> mystr</span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	    error = e</span><br><span class="line">	<span class="keyword">finally</span>:</span><br><span class="line">	    print(<span class="string">"before exit!"</span>)</span><br><span class="line">	    <span class="keyword">if</span> error:</span><br><span class="line">	        print(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> demo(<span class="string">'abc'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	print(<span class="string">"handle!"</span>)</span><br><span class="line">	<span class="keyword">raise</span> Exception(<span class="string">"some things"</span>)</span><br><span class="line"></span><br><span class="line">print(f)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">before enter!</span></span><br><span class="line"><span class="string">handle!</span></span><br><span class="line"><span class="string">before exit!</span></span><br><span class="line"><span class="string">some things</span></span><br><span class="line"><span class="string">abc</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>context_test生成器被contextmanager装饰之后，就可以当作上下文管理器对象来使用。当使用with语句启动的时候：</p>
<ul>
<li>首先执行yield之前的内容，所以before enter被打印；</li>
<li>接下来执行with语句块的内容，handle被打印；</li>
<li>然后raise抛出了异常，触法了yield之后的内容，before exit和some things相继被打印；</li>
<li>由于abc被yield返还， 被as子语句绑定到了f变量上，所以打印f变量的时候，输出的就是abc</li>
</ul>
<blockquote>
<p>被contextmanager装饰器装饰的生成器中，yield关键字和迭代没有任何关系。与之相比，此处更像是协程，代码执行到某一点之后暂停，去执行客户代码，直到客户代码再次启动协程。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL概述</title>
    <url>/2019/09/01/mysql%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做后端开发的这些年里，用过不少数据库，比如MySQL、MongoDb、redis、SQLServer等等，用的最多的还是MySQL。但长久以来，大部分对于MySQL的操作就局限于增删改查，没有更深一层次的了解。有空的时候，正想对此有一个系统化的梳理。在网上看到一个比较不错的作者写了一本MySQL的进阶书籍。</p>
<p>这一系列的文章应该都算是我对于这本书的一个阅读笔记，作者（微信公众号：<font color="orange">我们都是小青蛙</font>）搜索他的MySQL小册。</p>
<a id="more"></a>


<h2 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h2><h3 id="MySQL的结构"><a href="#MySQL的结构" class="headerlink" title="MySQL的结构"></a>MySQL的结构</h3><p>MySQL是一款C/S数据库软件，其组成可以分为两部分：客户端（client）以及服务器（server）</p>
<p>用户通过MySQL客户端连接到MySQL的服务器，并发送一系列的请求，MySQL接收到这些请求之后，根据请求内容不同对其进行不同的相应。</p>
<p>对于用户而言，通过客户端连接MySQL的服务器是需要账号密码的，通过身份认证之后，客户端与服务器的连接生效，可以进行下一步的操作。</p>
<p>MySQL服务器的名称默认是msqld，而客户端的名称默认是mysql</p>
<h3 id="启动MySQL服务端"><a href="#启动MySQL服务端" class="headerlink" title="启动MySQL服务端"></a>启动MySQL服务端</h3><p>MySQL服务器启动文件是mysqld，可以通过*<em>find / -name mysqld *</em>来查找此文件，正常启动的命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqld</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在mysql的安装过程中，还有一个执行脚本是<strong>mysqld_safe</strong>，这是一个启动脚本，在这个脚本中，会间接的调用mysqld文件，并且如果使用<strong>mysqld_safe</strong>来启动MySQL的话，还会顺便启动一个监控进程，这个进程的作用在于：<strong>当MySQL的服务器由于某种原因挂掉的时候可以帮助重启服务器程序</strong></p>
</blockquote>
<blockquote>
<p>除此之外，还有一个mysql.server文件，这个也是一个执行脚本。会间接的调用mysqld_safe文件，如果是使用mysql.server来启动/停止的话，启动命令是：<strong>mysql.server start/stop</strong></p>
</blockquote>
<blockquote>
<p>mysqld_multi文件可以在同一台计算机上启动不同的msyql实例 </p>
</blockquote>
<h3 id="启动MySQL客户端"><a href="#启动MySQL客户端" class="headerlink" title="启动MySQL客户端"></a>启动MySQL客户端</h3><p>MySQL的启动文件有很多，诸如mysql、mysqladmin、mysqldump、mysqlcheck等等。一般情况下，通过mysql文件启动即可。启动命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h主机 -u用户名 -p密码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数含义：</p>
<ul>
<li>-h    表示服务器的ip地址或者域名，也可用<strong>–host=主机名</strong>来表示</li>
<li>-u    表示登录服务器的用户名，也可用<strong>–user=用户名</strong>来表示</li>
<li>-p    表示登录服务器的密码，也可用<strong>–password=密码</strong>来表示</li>
</ul>
</blockquote>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>启动客户端的时候，如果使用的是类unix操作系统并且省略<strong>-u</strong>参数，会将登录当前操作系统的用户名当做登录MySQL服务器的用户名。比如当使用root账户登录MySQL服务器所在的服务器时候，如果使用命令<strong>mysql -p</strong>，其等效于<strong>mysql -uroot -p</strong></p>
<p>在windows中，默认的用户名是<strong>ODBC</strong></p>
<h3 id="客户端与服务器的连接"><a href="#客户端与服务器的连接" class="headerlink" title="客户端与服务器的连接"></a>客户端与服务器的连接</h3><p>MySQL的服务器和客户端启动后，本质上是两个不同的进程，<font color="orange">所以客户端进程向服务器进程发送请求并获取到回复的过程本质上是进程间通信的过程</font>。MySQL支持以下三种的进程通信方式。</p>
<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>在实际的生产环境中，MySQL的服务器和客户端往往运行在不同的主机中，在这两者之间，需要通过网络进行通信。而MySQL是采用TCP作为服务器和客户端之间的网络通信协议。TCP通信协议中，除了主机的ip地址，还需要要有端口号。而MySQL的默认端口号是3306，没有特殊指定的情况下，如果3306端口空闲，MySQL服务器启动的时候默认监听3306端口的网络数据。</p>
<p>如果说在MySQL服务器启动的时候3306端口已经被占用了或者需要特殊指定其它的端口，可以使用如下命令启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqld -P端口号</span><br></pre></td></tr></table></figure>

<p>MySQL客户端连接的端口号必须和服务器启动的端口号一致。在客户端启动连接的时候，指定端口号的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -P端口号 [其余参数]</span><br></pre></td></tr></table></figure>



<h4 id="命名管道和共享内存"><a href="#命名管道和共享内存" class="headerlink" title="命名管道和共享内存"></a>命名管道和共享内存</h4><p>在windows环境下，如果需要完成进程通信，可以使用命名管道和共享内存两种办法。同样，这也适用于在windwos 上MySQL的服务器和客户端通信。</p>
<p>使用命名管道进行通信的时候，需要在MySQL服务器启动命令的时候加上<strong>–enable-named-pipe</strong>，然后在启动客户端的时候加入<strong>–pipe</strong>或者<strong>–protocol=pipe</strong>的参数。</p>
<p>共享内存方式进行通信的条件必须是MySQL服务器和客户端在同一台计算机上。</p>
<p>使用共享内存来进行通信，需要在MySQL服务器启动命令的时候加上<strong>–shared-memory</strong>参数，在成功启动服务器之后，共享内存就成了本地客户端的默认连接方式，当然也可以在启动客户端的时候显示的指定，只需要加上<strong>–protocol=memory</strong>参数来显示指定。</p>
<h4 id="unix域套接字文件"><a href="#unix域套接字文件" class="headerlink" title="unix域套接字文件"></a>unix域套接字文件</h4><p>如果MySQL服务器和客户端都运行在同一台linux的机器上，其进程间的通信方式也可以使用unix域套接字。启动MySQL客户端的时候需要指定主机名为localhost（<strong>-hlocalhost</strong>），或者指定<strong>–protocol=socket</strong>的启动参数，即可使用unix域套接字进行通信了。</p>
<blockquote>
<p>MySQL服务器默认监听的域套接字文件位于<strong>/tmp/mysql.sock</strong>，这个文件也是可以更改的，更改方式为启动MySQL服务器程序的时候指定socket参数：</p>
<p><strong>mysqld –socket=/tmp/a.txt</strong></p>
<p>此时如果客户端要连接MySQL服务器的话，也需要显示指定unix域套接字文件地址：</p>
<p><strong>msqyl -hlocalhost -uroot –socket=/tmp/a.txt -p</strong></p>
</blockquote>
<h3 id="MySQL服务器对于客户端的处理流程"><a href="#MySQL服务器对于客户端的处理流程" class="headerlink" title="MySQL服务器对于客户端的处理流程"></a>MySQL服务器对于客户端的处理流程</h3><p>这个地方借用原书作者的一张图片</p>
<p><img src="/images/content/1.jpg" alt="mysql服务器处理流程"></p>
<p>无论MySQL的服务端和客户端采用什么方式进行通信，其最终都可以归结为<font color="orange">客户端向服务器发送SQL语句，服务器处理之后返还处理结果</font>，其中服务器的处理流程大致如上图所示。一般的SQL语句都会经历这么几个过程。</p>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p>MySQL的客户端和服务器之间通信方式已经有所了解，无论采用哪种方式进行通信，当客户端与服务器连接的时候，服务器进程都会创建一个新的线程来处理与这个客户端的交互，当客户端退出的时候，客户端与服务器连接断开，但是服务器创建的线程并不会立即销毁，而是将此线程缓存，当新的客户端与服务器进行连接的时候，将此线程分配给新的客户端，从而节省线程创建和销毁的开销。</p>
<p>从上述可知，每一个客户端与服务器的连接都是一个线程，当客户端太多的时候，也就是说服务器创建与客户端交互的线程过多，会严重的影响服务器的性能。所以MySQL服务器会有一个最大连接数量的限制，默认是100，可以对其进行修改。</p>
<p>MySQL客户端与服务器连接的时候，会携带一些参数，诸如用户名和密码等等，服务器会在连接的时候对其进行校验，校验通过的才允许连接，失败会拒绝连接。</p>
<p>连接成功建立后，服务器就可以处理来自于客户端的请求信息（SQL语句）了。</p>
<h4 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h4><p>MySQL服务器在获取到客户端的SQL语句后，往往不会立即执行，而是需要对其进行一定的处理，这个过程就是对SQL语句的解析和优化过程，这个过程一般分为3个步骤</p>
<ul>
<li><p>查询缓存：MySQL自身是有缓存的。MySQL的缓存机制是会检测涉及到的每一张表，一旦当表的结构或者数据被修改之后，缓存立即失效。并且，查询语句中如果存在某些系统函数，缓存也是会失效的。这样一来，MySQL维护缓存需要消耗一部分系统开销，但提升的系统性能却不是很高，总而言之就是性价比不高，所以MySQL不推荐使用缓存，并且在8.0版本之后将其移除。</p>
</li>
<li><p>语法解析：缓存没有命中或者缓存没有开启的情况下，SQL语句会正式进入查询阶段。MySQL服务器在接收到客户端传来的SQL文本之后，会对其进行编译解析，对文本的正确性进行判断，将其转化为MySQL自身的数据存储结构。</p>
</li>
<li><p>查询优化：在对原始的SQL进行解析之后，MySQL服务器还会对其进行优化，生成所谓的“执行计划”，提高查询效率</p>
<blockquote>
<p>可以使用explain来查看某个语句的执行计划</p>
</blockquote>
</li>
</ul>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p><font color="orange">存储引擎通俗点的叫法是 <strong>表处理器</strong></font>，就是对表的数据进行处理的模块。</p>
<p>为了方便管理，人们把<strong>连接管理</strong>、<strong>解析优化</strong>等不涉及真实数据存储的功能划分为<strong>mysql server功能</strong>，而将真实存储数据的功能划分为存储引擎，每个存储引擎都可以理解为封装好的模块，向上层，即mysql server提供统一的调用接口。</p>
<p>当mysql server完成对于sql的解析优化之后，就可以调用存储引擎对于数据进行处理，然后将结果返还给客户端。</p>
<h3 id="存储引擎的一些操作"><a href="#存储引擎的一些操作" class="headerlink" title="存储引擎的一些操作"></a>存储引擎的一些操作</h3><ul>
<li>查看当前服务器支持的存储引擎</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建表的时候设置存储引擎</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name ( 字段 ) ENGINE&#x3D;MyISAM;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改表的存储引擎</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ENGINE&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看表结构（表引擎）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE table_name\G;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>\G的作用是将横向表结构修改为竖向表结构</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>使用future处理并发</title>
    <url>/2020/04/11/%E4%BD%BF%E7%94%A8future%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>concurrent.future模块的主要特色是<strong>ThreadPoolExecutor</strong>以及<strong>ProcessPoolExecutor</strong>。这两个类实现的接口能分别在不同的线程或者进程中指定<strong>可调用对象</strong>。<br>这两个类在内部维护着一个工作的线程/进程池，以及要实现的任务队列。不过接口抽象的层级很高，一般的简单并发任务，无需关心实现的细节。</p>
<a id="more"></a>
<h2 id="future"><a href="#future" class="headerlink" title="future"></a>future</h2><p>Python3.4起，标准库中有两个名为Future的类：</p>
<ul>
<li><p>concurrent.futures.Future</p>
</li>
<li><p>asyncio.Feture<br>其Future的实例表示<strong>可能已经完成</strong>和<strong>尚未完成</strong>的延迟任务。<br>使用Future的实例封装待完成操作，可以将其放入队列，并且其完成的状态可以查询，获取结果/异常。<br>对于编程人员而言，没有特殊情况最好不要自己是实例化Future，而将这项任务交由并发框架完成。原因很简单：future表示终将要发生的事情。也就是说这项任务的执行时间已经排定了。因此，只有排定将某件事情交给concurent.futures.Executor子类处理的时候，才会创建concurrent.futures.Future实例。<br>同时，客户端的代码最好不要去改变future的状态，因为我们无法控制计算何时结束。<br>future的一些常用方法：</p>
</li>
<li><p>done()    方法不阻塞，返回的是布尔值，表明future链接的可调用对象是否已经调用结束。</p>
</li>
<li><p>add_done_callback(caller)        接受一个可调用对象，当future链接的可调用对象调用结束的时候，将其当作回调函数执行。</p>
</li>
<li><p>result()    当future运行结束的时候调用该方法，则返回可调用对象的结果/异常。</p>
</li>
</ul>
<h2 id="excutor的submit和map"><a href="#excutor的submit和map" class="headerlink" title="excutor的submit和map"></a>excutor的submit和map</h2><p>实现一个下载任务的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.thread <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> as_completed</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CC          = <span class="string">'CN IN US ID BP PK NG BD RU JP'</span>.split()</span><br><span class="line">BASE_URL    = <span class="string">'http://flupy.org/data/flags'</span></span><br><span class="line">DIR         = <span class="string">'/Users/livis/Desktop'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_flag</span><span class="params">(img, name)</span>:</span></span><br><span class="line">    path = os.path.join(DIR, name)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text, end=<span class="string">''</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;&#125;/&#123;&#125;.gif'</span>.format(BASE_URL, cc.lower(), cc.lower())</span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> res.content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    image = get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many_map</span><span class="params">(ccs)</span>:</span></span><br><span class="line">    workers = len(ccs)</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:</span><br><span class="line">        res = executor.map(download_one, ccs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len(list(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many_submit</span><span class="params">(ccs)</span>:</span></span><br><span class="line">    workers = len(ccs)</span><br><span class="line">    futures = list()</span><br><span class="line">    results = list()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> ccs:</span><br><span class="line">            futures.append(executor.submit(download_one, cc))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">            res = future.result()</span><br><span class="line"></span><br><span class="line">            results.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># download_many_submit(CC)</span></span><br><span class="line">    download_many_map(CC)</span><br></pre></td></tr></table></figure>
<p>使用map，获取的结果顺序不会会变化。<br>而使用submit，获取的结果的顺序会发生改变。</p>
<h2 id="显示任务处理进度"><a href="#显示任务处理进度" class="headerlink" title="显示任务处理进度"></a>显示任务处理进度</h2><p>为任务处理添加可视化的进度显示，可以使用TQDM模块实现。</p>
<h3 id="最简单的tqdm示例"><a href="#最简单的tqdm示例" class="headerlink" title="最简单的tqdm示例"></a>最简单的tqdm示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm  </span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> time </span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">for</span> item <span class="keyword">in</span> tqdm(range(<span class="number">10</span>)): </span><br><span class="line">   ...:     time.sleep(<span class="number">0.2</span>) </span><br><span class="line">   ...:                                                                                                         </span><br><span class="line"><span class="number">100</span>%|████████████████████████████ <span class="number">10</span>/<span class="number">10</span> [<span class="number">00</span>:<span class="number">02</span>&lt;<span class="number">00</span>:<span class="number">00</span>,  <span class="number">4.91</span>it/s]</span><br></pre></td></tr></table></figure>
<p>tqdm能够实现任何的可迭代对象，生成一个迭代器。使用这个迭代器的时候，显示进度条和完成全部迭代预计的剩余时间。</p>
<h3 id="将任务进度和as-completed结合"><a href="#将任务进度和as-completed结合" class="headerlink" title="将任务进度和as_completed结合"></a>将任务进度和as_completed结合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many_submit</span><span class="params">(css)</span>:</span></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">with</span> ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:</span><br><span class="line">	        <span class="keyword">for</span> cc <span class="keyword">in</span> ccs:</span><br><span class="line">	            futures.append(executor.submit(download_one, cc))</span><br><span class="line">	</span><br><span class="line">	        it = tqdm.tqdm(as_completed(futures), total=len(CC))</span><br><span class="line">	        <span class="keyword">for</span> future <span class="keyword">in</span> it:</span><br><span class="line">	            res = future.result()</span><br><span class="line">	</span><br><span class="line">	            results.append(res)</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<p>as_completed()返回的是个可迭代对象，因此可以使用tqdm。<br>需要注意的是，因为as_completed()无法使用len，所以需要显示的指定元素的数量，这样才能预计剩余的工作量。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>future</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式之元类</title>
    <url>/2019/04/04/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%95%AA%E5%A4%96%E7%AF%87%E5%85%83%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>为了简单的说明元类，此篇内容不考虑abc模块</p>
</blockquote>
<h2 id="Python的元类"><a href="#Python的元类" class="headerlink" title="Python的元类"></a>Python的元类</h2><p>在上一篇文章<a href="/2019/03/31/%E5%8D%95%E4%BE%8B/" title="单例">单例</a>中，我们通过元编程实现了单例模式。</p>
<p>但是到底什么是元类？我觉得这篇文章写的非常好，分享一下。</p>
<p><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="noopener">什么是Python中的元类</a></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>简而言之，元类是Python中产生类的类，或者说是产生类对象的类。Python是一门动态解释型强类型语言，在Python的世界中，我们强调<strong>万物皆对象</strong>，类本身也是一个对象，也是由其它类产生的。而type就是Python中常用的元类。</p>
<a id="more"></a>
<h2 id="元类控制类的产生"><a href="#元类控制类的产生" class="headerlink" title="元类控制类的产生"></a>元类控制类的产生</h2><p>通过执行元类，我们可以动态的产生类。但还不仅仅于此，我们甚至可以操控，设计或是定义类的产生。通过下面一段代码，我们感受一下元类的魅力。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, className, classParents, classDict)</span>:</span></span><br><span class="line">        print(className)</span><br><span class="line">        print(classParents)</span><br><span class="line">        print(classDict)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, className, classParents, classDict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySample</span><span class="params">(object, metaclass=MyMeta)</span>:</span></span><br><span class="line">    </span><br><span class="line">    myProperty = <span class="string">"property"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行上述的结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>This <span class="keyword">is</span> className:  MySample</span><br><span class="line">&gt;&gt;&gt; This is classParents:  (&lt;class 'object'&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>This <span class="keyword">is</span> classDict:  &#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__qualname__'</span>: <span class="string">'MySample'</span>, <span class="string">'myProperty'</span>: <span class="string">'property'</span>, <span class="string">'func'</span>: &lt;function MySample.func at <span class="number">0x00000223C8B74B70</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们定义了一个元类，让它继承type元类，在<strong>new</strong>方法中打印出它的参数。同时，使用metaclass=MyMeta指定MySample的产生元类。既然类对象也是元类产生的，那么元类的<strong>new</strong>方法就是产生类对象的方法。</p>
<p>在上述代码执行过程中，python解释器遇到关键字class，在产生类对象的过程中输出了三个参数：</p>
<ul>
<li>第一个参数className: 类对象的名称，就是要生产的类的名称</li>
<li>第二个参数classParents: 类的父类，就是要生产的类的继承类</li>
<li>第三个参数classDict: 这是一个字典，有几个固定的key-value（比如<strong>module</strong>之类的），剩下的可以大致分成两部分：<ul>
<li>类属性</li>
<li>该类的方法（不是类方法）</li>
</ul>
</li>
</ul>
<h3 id="改变类的属性和方法"><a href="#改变类的属性和方法" class="headerlink" title="改变类的属性和方法"></a>改变类的属性和方法</h3><p>通过上面的例子，我们知道了类对象的产生过程。既然元类的<strong>new</strong>方法会产生类对象，那么，元类的<strong>init</strong>方法是不是也会初始化类对象，并为其附上一定属性。如果是的话，我们能不能通过元类的<strong>init</strong>来在类对象初始化的时候，改变类对象的行为呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, className, classParents, classDict)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, className, classParents, classDict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, className, classParents, classDict)</span>:</span></span><br><span class="line">        super().__init__(className, classParents, classDict)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> classDict.items():</span><br><span class="line">            <span class="keyword">if</span> k == <span class="string">"myProperty"</span>:</span><br><span class="line">                setattr(self, k, v[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySample</span><span class="params">(object, metaclass=MyMeta)</span>:</span></span><br><span class="line">    </span><br><span class="line">    myProperty = <span class="string">"property"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(MySample.myProperty)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行上述的结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ytreporp</span><br></pre></td></tr></table></figure>
<p>对第一个例子做了一点小小的改动，实现了MyMeta元类的<strong>init</strong>方法，并在其中进行了判断，如果类对象具有“myProperty”类属性，那么，将其值反转。</p>
<p>可以看见，通过元类编程，我们很容易就实现了对类产生过程中的控制，甚至能够在类产生的时候改变类的行为。</p>
<blockquote>
<p>元类中，类属性的初始化和改变也可以在<strong>new</strong>方法中完成。单个人觉得最好还是在<strong>init</strong>中实现，每个特定的方法有特定的职责。</p>
</blockquote>
<h3 id="强制子类实现方法"><a href="#强制子类实现方法" class="headerlink" title="强制子类实现方法"></a>强制子类实现方法</h3><p>那么元类编程有没有什么用途呢？在文章的开头我们说通过元类可以实现真正意义上的单例的模式，不过在此之前，我们先看看元类的其他用途</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumenBase</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.eat()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">'cannot call run of base class HumenBase'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Humen</span><span class="params">(HumenBase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h = Humen()</span><br><span class="line">h.do()</span><br></pre></td></tr></table></figure>
<p>在上述代码中，是一个多态的实现，要求子类必须实现eat方法，才能执行do。</p>
<p>但是有的时候，我们往往建立模块代码之后，代码是交由别人使用的，当他人在继承我们实现的基类的时候，这个就不太容易体现出来，尤其是当其没有执行do方法的时候，可能不太会知道，我们可以通过元类编程来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, className, classParents, classDict)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> className != <span class="string">"HumenBase"</span> <span class="keyword">and</span> <span class="string">"eat"</span> <span class="keyword">not</span> <span class="keyword">in</span> classDict:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">'cannot call run of base class HumenBase'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, className, classParents, classDict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumenBase</span><span class="params">(metaclass=MyMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.eat()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">'cannot call run of base class HumenBase'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Humen</span><span class="params">(HumenBase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>通过指定基类的元类，在其产生过程中判断该类有没有实现eat方法，如果没有就直接报错，这样一来，如果想要成为HumanBase的子类，就必须实现eat方法</p>
<h3 id="元类中的call"><a href="#元类中的call" class="headerlink" title="元类中的call"></a>元类中的<strong>call</strong></h3><p>我们探究了元类中的<strong>new</strong>和<strong>init</strong>，和普通类的功能大体相似（不过元类的<strong>init</strong>好像不负责初始化属性，这个还有待研究）。我们再来看一下另一个比较重要的魔法方法<strong>call</strong> 。</p>
<p>在普通的类中<strong>call</strong>方法的实现，能够让该类的实例具有像函数一样的访问功能。比如现在有一个类A，实例化了对象a，当我们执行a()的时候，实际就会出发<strong>call</strong>方法，就把对象a当作函数一样来访问。</p>
<p>那么对于元类来说，它实例化的对象是类对象，当我们以<strong>类对象()</strong>的方式进行访问的时候，会不会触发元类中的<strong>call</strong>呢？如果是的话，就会引发一个问题，<strong>类对象()</strong>的访问方式，又是类对象实例化对象的方式，那么，是不是说，元类中的<strong>call</strong>方法的实现，能够控制类对象实例化的过程？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, className, classParents, classDict)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, className, classParents, classDict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"this is args: "</span>, args)</span><br><span class="line">        print(<span class="string">"this is kwargs: "</span>, kwargs)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"haha! no object created"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span><span class="params">(metaclass=MyMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"object created!"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"object has been init"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Simple(<span class="number">1</span>, name=<span class="string">"zjl"</span>)</span><br><span class="line">print(s)</span><br><span class="line">print(type(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行上述的结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>this <span class="keyword">is</span> args:  (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>this <span class="keyword">is</span> kwargs:  &#123;<span class="string">'name'</span>: <span class="string">'zjl'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>haha! no object created</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当我们在元类中实现类<strong>call</strong>方法后，通过该元类产生的类，其实例化对象的过程并没有触发自身的<strong>new</strong>和<strong>init</strong>方法，而是触发了元类的<strong>call</strong>方法。而<strong>call</strong>返回的，就是该类实例化的对象。</p>
<h2 id="元类和单例"><a href="#元类和单例" class="headerlink" title="元类和单例"></a>元类和单例</h2><p>聊了这么多，终于聊到了单例模式和元类的关系，让我们来回顾一下，经典的元类实现单例模式的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__instance = <span class="literal">None</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__instance = super().__call__(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>如果能够明白我上面介绍的元类的<strong>call</strong>方法，那么这段代码应该很容易理解。</p>
<p>但是我们的目的并不是它，这段代码我们在上一次的文章中已经实现过了，我们想，有没有什么办法在Python中实现严格意义上的饿汉单例模式呢？如果我在类一产生的时候，就产生了唯一的一个实例，是不是就算是饿汉单例模式呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        classObject = super().__new__(cls, *args, **kwargs)</span><br><span class="line">        classObject._instance = classObject()</span><br><span class="line">        cls.__call__ = cls.__call</span><br><span class="line">        <span class="keyword">return</span> classObject</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass=Meta)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = A()</span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码执行的结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>在元类的<strong>new</strong>方法中，一旦我们获取到了类对象，立即将其实例化，并赋值给类对象的属性_instance，然后再对类对象进行动态的方法赋值，强行将call__方法绑定上类对象，并命名为<strong>call</strong>，这样，当我们执行<strong>类对象()</strong>的时候，实际返回的就是我们第一次实例化类对象的对象。这样基本就符合饿汉单例模式的意思：当类产生的时候就实例化该对象，以后每次实例化均返回该类唯一的一个对象。</p>
<p>在上述方法中因为多线程而产生问题么，我觉得应该是不会的，程序执行的时候，唯一的单例已经产生了，后续返还的都是唯一的一个。</p>
<p>那么再Java中，饿汉单例模式，是将让该类彻底无法实例化，然后通过静态方法来返还单例。在Python中，我们也能模拟这一过程，只需要改变一点点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        classObject = super().__new__(cls, *args, **kwargs)</span><br><span class="line">        classObject._instance = classObject()</span><br><span class="line">        cls.__call__ = cls.__call</span><br><span class="line">        <span class="keyword">return</span> classObject</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"can not generate class"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass=Meta)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A.get_instance()</span><br><span class="line">b = A.get_instance()</span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"></span><br><span class="line">A()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码执行的结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Traceback (most recent call last):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> File <span class="string">"c:/Users/Livis/Desktop/test/1.py"</span>, line <span class="number">24</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> File <span class="string">"c:/Users/Livis/Desktop/test/1.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> __call</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="keyword">raise</span> Exception(<span class="string">"can not generate class"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Exception: can <span class="keyword">not</span> generate <span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>
<p>做了一个小小的改变，这下只能通过get_instance函数来获取单例。不过我还是更喜欢上面的一种方式，更加的Pythonic。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇中，我们大致介绍了一下元类，元类其实复杂，但是也很简单，关键就是类也是对象这个概念。对于元类本身而言，也就是三点：</p>
<ul>
<li>拦截类的创建</li>
<li>修改类</li>
<li>返回修改的类</li>
</ul>
<p>元类最经典的应用，就是ORM框架的设计，有兴趣的可以看一看SQLAlchemy的源码对于ORM的实现，相信你会对元类的理解更加深刻。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例</title>
    <url>/2019/03/31/%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="设计模式之单例"><a href="#设计模式之单例" class="headerlink" title="设计模式之单例"></a>设计模式之单例</h2><p>单例模式，属于创建类型中一种常见，也很简单的设计模式。如果一个类被设计成单例模式，那么它在整个进程/线程中将只有一个实例对象。</p>
<p>在软件设计中，有很多单例的应用场景，下面简单的介绍一下常见的几种：</p>
<a id="more"></a>
<ol>
<li>回收站：在系统运行的整个过程中，回收站一直维持着仅有的一个实例；</li>
<li>数据库连接池： 数据库的连接是一种非常昂贵的消耗资源的行为，使用单例模式维持数据库的链接就能大大降低这种损耗；</li>
<li>唯一ID：部分生成唯一ID也可以使用单例模式来实现；</li>
</ol>
<h2 id="Python实现单例模式"><a href="#Python实现单例模式" class="headerlink" title="Python实现单例模式"></a>Python实现单例模式</h2><h3 id="经典单例模式"><a href="#经典单例模式" class="headerlink" title="经典单例模式"></a>经典单例模式</h3><p>考虑单例模式的定义是 <strong>只实例化一个对象，并提供一个访问它的全局访问点</strong>，那么在实现单例模式的时候只需要做到</p>
<ol>
<li>实例化一个对象；</li>
<li>当需要再次实例化一个对象的时候，将已经实例化的对象提供出来；</li>
</ol>
<p>__new__()方法是Python中实例化对象的方法，我们需要在__new__()中控制单例的实现过程。</p>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">"_instance"</span>):</span><br><span class="line">            setattr(cls, <span class="string">"_instance"</span>, super().__new__(cls, *args, **kwargs))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>
<p>在<strong>new</strong>()实例化对象的时候，我们先对其进行判断，如果不存存在类属性_instance，则为其设置该属性，同时将该属性指向第一个实例化后的对象。以后再实例化对象的时候，直接将这个属性返回，就能保证只实例化一个对象。</p>
<h4 id="经典模式的懒汉与饿汉"><a href="#经典模式的懒汉与饿汉" class="headerlink" title="经典模式的懒汉与饿汉"></a>经典模式的懒汉与饿汉</h4><p>在经典的单例模式中，也分为两个种情形。第一种是<strong>饿汉模式</strong>，其描述为当类被创建的时候（也有表述为程序第一次执行的时候），单例对象已经被创建，以后每次均是将此对象返还；第二种模式是<strong>懒汉模式</strong>,其描述为当程序执行的时候不会去创建，当需要的时候再去创建，以后每次获取此单例，均判断获取。</p>
<p>Java对此的做法是私有化构造方法，使得外界无法通过此类来创建实例，然后提供静态方法，来实现懒汉or饿汉的单例模式。</p>
<p>而在Python中，我们无法将构造方式私有化。而很多人都将上述的经典实现方法描述为饿汉模式，他们都认为下面的才是懒汉模式的实现方式。对于这一点，我个人持保留意见。我认为的是，在Python中，不存在所谓的饿汉单例模式，因为我们无法在类创建的时候就能够提供此类的实例对象（不通过元类编程）。下面我贴出大众认为的Python中的懒汉模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'出自《python设计模式 第二版》'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Singleton.__instance:</span><br><span class="line">            print(<span class="string">" __init__ method called.."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Instance already created:"</span>, self.getInstance())</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getInstance</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">            cls.__instance = Singleton()</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br></pre></td></tr></table></figure>

<h4 id="懒汉模式的线程安全问题"><a href="#懒汉模式的线程安全问题" class="headerlink" title="懒汉模式的线程安全问题"></a>懒汉模式的线程安全问题</h4><p>暂且将懒汉与饿汉的争议放到一边，回头看看经典单例模式的代码。</p>
<p>熟悉多任务编程的同学肯定会发现，上述的代码是有可能出现线程竞争的。当多线程的情况下，if 条件判断语句 很可能会创建出两个“单例” ，如下图所示：<br><img src="/images/content/thread.jpg" alt="thread"></p>
<p>所以考虑到线程安全问题，需要对单例创建的过程加上 <strong>锁</strong><br>以第一段代码为例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    LOCK = Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> cls.LOCK:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">"_instance"</span>):</span><br><span class="line">                setattr(cls, <span class="string">"_instance"</span>, super().__new__(cls, *args, **kwargs))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>
<p>这样加上线程锁之后，线程安全问题是得到了保障。但是引发出了一个新的问题：每次获取单例对象的时候，都需要获取线程锁和释放线程锁，这是非常消耗资源的一件事情。</p>
<p>将上述代码做一个小小的改变，即双重校验锁。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    LOCK = Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">"_instance"</span>):</span><br><span class="line">            <span class="keyword">with</span> cls.LOCK:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">"_instance"</span>):</span><br><span class="line">                    setattr(cls, <span class="string">"_instance"</span>, super().__new__(cls, *args, **kwargs))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<h3 id="另一种意义的单例—Monostate"><a href="#另一种意义的单例—Monostate" class="headerlink" title="另一种意义的单例—Monostate"></a>另一种意义的单例—Monostate</h3><p>严格的来说，Monostate也是一种设计模式。Mono,单一的；state，状态， 单一的状态。换句话说，MonoState并不限制创建对象的个数，但是它的状态却只有一个状态。</p>
<p>让我们来看看在Python下，如何实现Monostate</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonoState</span>:</span></span><br><span class="line">    _state = dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__ = self._state</span><br><span class="line"></span><br><span class="line">a = MonoState()</span><br><span class="line">b = MonoState()</span><br><span class="line"></span><br><span class="line">setattr(a, <span class="string">"key"</span>, <span class="string">"this is a value"</span>)</span><br><span class="line">print(b.key)            <span class="comment"># 输出结果this is a value</span></span><br><span class="line">print(a <span class="keyword">is</span> b)           <span class="comment"># 输出 False</span></span><br></pre></td></tr></table></figure>
<p>上述实现中，虽然a和b是两个不同的对象，但是这两个不同的对象却共享属性</p>
<p>在Python中，<strong>dict</strong>实现以字典的方式保存对象的所有属性。我们在这个对象初始化的时候，直接将该对象的<strong>dict</strong>指向了同一个片内存空间，保证了只要是这个类创建出来的对象，都能共享同一个状态。当一个对象的属性更新的时候，其余所有对象属性随之更新。</p>
<h3 id="元类实现单例模式"><a href="#元类实现单例模式" class="headerlink" title="元类实现单例模式"></a>元类实现单例模式</h3><p>在大多属的编程语言中，类是一种数据类型，被描述成为一组具有共性的事物的抽象，类是用来实例化对象的，在Python中，这一点也不例外。但是，在Python的世界里，类除了具有上述身份外，它本身也是一个对象，只不过这个对象比较特别，它可以实例化其它的对象。在Python程序被执行的时候，类对象被创建。</p>
<p>既然类也是一个对象，是由其它类生成而来的，我们只要找到这个方法，在类创建的时候对他做一些限制，也是可以实现单例模式的。Python，这一类的编程方式称之为元编程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__instance = <span class="literal">None</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__instance = super().__call__(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在上述代码示例中通过metackass=Singleton让Singleton产生类Spam。类对象Spam作为Singleton的实例化对象而存在。由于Spam是一个对象，并且实现了<strong>call</strong>方法，所以对象Spam可以被当成函数执行。而Spam()又是类Spam实例化对象的方式。所以s = Spam()的时候，将会调用<strong>call</strong>方法，对象s 就是<strong>call</strong>return的结果。这就是通过元编程实现单例的方式</p>
<p>在这种方式中，我们没有修改要生成单例的类，而是通过修改了它的创建方式来间接形成单例模式。该方法还有一个好处，通过指定metaclass的方式可以很方便的生成N多个单例类，而不用一个一个的修改它们。</p>
<blockquote>
<p>上面我们说过，我们无法在类创建的时候就能够提供此类的实例对象，前提是不通过元编程的方式，现在我们有了元编程，可以很灵活的实现这一点。关于更多元编程来实现单例的方式，包括我认为真正的饿汉单例，请看<a href="/2019/04/04/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%95%AA%E5%A4%96%E7%AF%87%E5%85%83%E7%B1%BB/" title="单例模式之元类">单例模式之元类</a></p>
</blockquote>
<h3 id="模块单例"><a href="#模块单例" class="headerlink" title="模块单例"></a>模块单例</h3><p>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以采用如下方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Singleton()</span><br><span class="line"><span class="comment"># 保存为mysingleton.py文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第二个为文件中导入</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> s</span><br></pre></td></tr></table></figure>

<h2 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h2><p>虽然单例模式在许多情况下效果很好，但这种模式仍然存在一些缺陷。</p>
<ol>
<li>全局变量可能在某处已经被误改，但是开发人员仍然认为它们没有发生变化，而该变量还在应用程序的其他位置被使用。</li>
<li>可能会对同一对象创建多个引用。由于单例只创建一个对象，因此这种情况下会对同一个对象创建多个引用。</li>
<li>所有依赖于全局变量的类都会由于一个类的改变而紧密耦合为全局数据，从而可能在无意中影响另一个类。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于单例模式来说，以下几点需要牢记。</p>
<ol>
<li>在许多实际应用程序中，我们只需要创建一个对象，如线程池、缓存、对话框、注册表设置等。如果我们为每个应用程序创建多个实例，则会导致资源的过度使用。单例模式在这种情况下工作得很好。</li>
<li>单例是一种经过时间考验的成熟方法，能够在不带来太多缺陷的情况下提供全局访问点。<br>当然，该模式也有几个缺点。当使用全局变量或类的实例化非常耗费资源但最终却没有用到它们的情况下，单例的影响可以忽略不计。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>可迭代对象、迭代器和生成器</title>
    <url>/2020/02/18/%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代是数据处理的基石，扫描内存中放不下数据集的时候，需要有一种能够惰性获取数据的方法，即按需一次获取一个数据项。这就是迭代器模式（Iterator Patten）。<br>在Python中，实际上是内置了迭代器模式的，避免自己手动实现。</p>
<a id="more"></a>
<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>通常来说，判断一个对象是不是属于某一类，可以使用isinstance的方法，判断可迭代对象也可以使用。<br>isinstance(obj, collections.abc.Iterable)<br>但是会有下面一个现象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterator)</span>:</span></span><br><span class="line">		self.iterator = list(iterable)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.iterator[index]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(m, coolections.abc.Iterable)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">··· 	<span class="keyword">print</span> i</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="iter函数"><a href="#iter函数" class="headerlink" title="iter函数"></a>iter函数</h2><p>在MyList的实例并没有通过isinstance的判断，但是MyList的实例依然可以被for循环处理。<br>是因为对象可以被迭代的原因： <strong>iter函数</strong>。<br>内置的iter函数主要会有以下三个方面的作用：  </p>
<ul>
<li>检查对象是否实现了__iter__方法，如果实现，调用它获取一个迭代器。</li>
<li>没有实现__iter__方法，但是实现了__getitem__方法，iter会为其创建一个迭代器，尝试从索引0开始获取元素。</li>
<li>如果尝试失败，抛出TypeError的异常，并指明实例为不可迭代对象。</li>
</ul>
<p><strong>所以，检查一个对象是否可迭代，最准确的方法是调用iter函数，如果不是可迭代对象，捕捉TypeError异常。</strong></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可迭代对象和迭代器之间的关系：Python从可迭代对象中获取迭代器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"abc"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">···		print(char)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)							<span class="comment"># 取出迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">···		<span class="keyword">try</span>:</span><br><span class="line">···			print(next(it))	</span><br><span class="line">···		<span class="keyword">except</span> StopIteration:</span><br><span class="line">···			<span class="keyword">break</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>next()函数能够返回迭代器的下一个元素，而StopIteration这个异常则表明迭代到头了，在for循环内部，或者的其他迭代上下文中，Python会自己处理这个异常。<br>对于一个标准的迭代器来说，主要实现两个方法</p>
<ul>
<li>__iter__ 迭代器的__iter__一般返回自身，也就是self</li>
<li>__next__ 返回下一个元素</li>
</ul>
<h3 id="Python的经典的迭代协议的实现"><a href="#Python的经典的迭代协议的实现" class="headerlink" title="Python的经典的迭代协议的实现"></a>Python的经典的迭代协议的实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lis)</span>:</span></span><br><span class="line">		self._lis = lis</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> MyListIterator(self._lis)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListIterator</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lis)</span>:</span></span><br><span class="line">		self._lis = lis</span><br><span class="line">		self._index = <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			item = self._lis[self._index]</span><br><span class="line">		<span class="keyword">except</span> IndexError:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration</span><br><span class="line">		</span><br><span class="line">		self._index += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> item</span><br><span class="line">			</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>

<p>在这个实现中，MyList作为可迭代对象的类，而MyListIteration是生成迭代器的类。<br>在每次可迭代对象需要进行迭代的时候，iter函数都会触法可迭代对象的__iter__的方法，生成一个新的迭代器对象。<br>而每一个独立的迭代器对象在迭代终止的时候，由于其index已经到达终点，无法再次获取元素。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>只要Pytho中的函数带有yield关键字，该函数就是生成器函数。</p>
<h3 id="使用生成器函数改写上面的迭代器"><a href="#使用生成器函数改写上面的迭代器" class="headerlink" title="使用生成器函数改写上面的迭代器"></a>使用生成器函数改写上面的迭代器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lis)</span>:</span></span><br><span class="line">		self._lis = lis</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> item <span class="keyword">in</span> self._lis:</span><br><span class="line">			<span class="keyword">yield</span> item</span><br><span class="line">		<span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>使用关键字yield，直接将MyList的__iter__变成一个生成器函数，生成器函数是特殊的迭代器。</p>
<h3 id="python标准库中的一些常用的生成器函数"><a href="#python标准库中的一些常用的生成器函数" class="headerlink" title="python标准库中的一些常用的生成器函数"></a>python标准库中的一些常用的生成器函数</h3><h4 id="用于过滤的生成器函数"><a href="#用于过滤的生成器函数" class="headerlink" title="用于过滤的生成器函数"></a>用于过滤的生成器函数</h4><table>
<thead>
<tr>
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>itertools</td>
<td>compress(it, selector_it)</td>
<td>并行的处理两个可迭代的对象，如果select_it的元素是真值，产出it中对应的元素</td>
</tr>
<tr>
<td>itertools</td>
<td>dropwhile(predicate, it)</td>
<td>使用predicate函数处理it的各个元素，从第一个返回结果为False的开始，然后产出剩下的各个元素</td>
</tr>
<tr>
<td>itertools</td>
<td>takewhile(predicate, it)</td>
<td>产出predicate 返回真值的时候产生对应的元素，遇到第一个Flase立即停止</td>
</tr>
<tr>
<td>itertools</td>
<td>filter(predicate, it)</td>
<td>使用predicate函数处理it的各个元素， 如果函数结果返回为真值，产出对应元素。如果predicate函数为None，产出it中为真值的元素</td>
</tr>
<tr>
<td>itertools</td>
<td>filterfalse(predicate, it)</td>
<td>filter 的对立函数</td>
</tr>
<tr>
<td>itertools</td>
<td>islice(it, stop) 或者 islice(it, start, stop, step=1)</td>
<td>产出it的切片，it[: stop] 或者 it[start: stop: step]， it可以是任何可迭代对象</td>
</tr>
</tbody></table>
<h5 id="compress-it-selector-it"><a href="#compress-it-selector-it" class="headerlink" title="compress(it, selector_it)"></a>compress(it, selector_it)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"linjiechuang"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(compress(name, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line">[<span class="string">'l'</span>, <span class="string">'n'</span>, <span class="string">'i'</span>, <span class="string">'c'</span>, <span class="string">'h'</span>, <span class="string">'u'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(conpress(name, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line">[<span class="string">'l'</span>, <span class="string">'n'</span>]</span><br></pre></td></tr></table></figure>

<h5 id="dropwhile-predicate-it"><a href="#dropwhile-predicate-it" class="headerlink" title="dropwhile(predicate, it)"></a>dropwhile(predicate, it)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"zzmmoozz"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(dropwhile(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> <span class="string">"zo"</span>, name))</span><br><span class="line">[<span class="string">'m'</span>, <span class="string">'m'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>]</span><br></pre></td></tr></table></figure>
<p>lambda 做检查，当第一个元素‘z’传递进去的时候，返回True，继续检查；第二个元素传递进去返回还是True；第三个例子传递进去，返回时False， 从此不再检查，剩下元素直接需要的时候返回。</p>
<h5 id="takewhile-predicate-it"><a href="#takewhile-predicate-it" class="headerlink" title="takewhile(predicate, it)"></a>takewhile(predicate, it)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"zzmmoozz"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(takewhile(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> <span class="string">"zo"</span>, name))</span><br><span class="line">[<span class="string">'z'</span>, <span class="string">'z'</span>]</span><br></pre></td></tr></table></figure>
<p>与dropwhile类似，但是相反，dropwhile是遇到第一个非真值开始产出，而takewhile遇到第一个非真值停止。</p>
<h5 id="filter-predicate-it"><a href="#filter-predicate-it" class="headerlink" title="filter(predicate, it)"></a>filter(predicate, it)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"zzmmoozz"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> <span class="string">"zo"</span>, name))</span><br><span class="line">[<span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="literal">None</span>, numbers))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>filter 有一个特性是predicate函数是可以为None的，当predicate为None的时候，filter直接将it中的真值元素筛选出来。</p>
<h5 id="filterfalse-predicate-it"><a href="#filterfalse-predicate-it" class="headerlink" title="filterfalse(predicate, it)"></a>filterfalse(predicate, it)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"zzmmoozz"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filterfalse(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> <span class="string">"zo"</span>, name))</span><br><span class="line">[<span class="string">'m'</span>, <span class="string">'m]</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; numbers = [1, 0, 1, 0]</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; list(filterfalse(None, numbers))</span></span><br><span class="line"><span class="string">[0, 0]</span></span><br></pre></td></tr></table></figure>
<p>与filter函数的检查条件相反。</p>
<h5 id="islice-it-start-stop-step-islice-it-stop"><a href="#islice-it-start-stop-step-islice-it-stop" class="headerlink" title="islice(it, start, stop, step)/islice(it, stop)"></a>islice(it, start, stop, step)/islice(it, stop)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(islice(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">[<span class="number">2</span>, ,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h4 id="用于映射的生成器函数"><a href="#用于映射的生成器函数" class="headerlink" title="用于映射的生成器函数"></a>用于映射的生成器函数</h4><table>
<thead>
<tr>
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>itertools</td>
<td>accmulate(it, [func, ])</td>
<td>产生累计的总和， 如果提供了func， 将前两个元素传递给它，返回计算结果， 然后把计算结果和下一个元素传递给它， 以此类推</td>
</tr>
<tr>
<td>内置</td>
<td>emumerate(it, start=0)</td>
<td>产生两个元素组成的元祖，第一个元素是index， 从start开始计数，第二个元素是对应index的it的值</td>
</tr>
<tr>
<td>内置</td>
<td>map(func, it, [it2, it3…])</td>
<td>把it中的元素传递给func，产出结果， it的个数与func的参数相等</td>
</tr>
<tr>
<td>itertools</td>
<td>starmap(func, it)</td>
<td>将it中的元素传给func， 然后产出结果</td>
</tr>
</tbody></table>
<h5 id="accumulate-it-func"><a href="#accumulate-it-func" class="headerlink" title="accumulate(it, [func, ])"></a>accumulate(it, [func, ])</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accumulate(range(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>]		<span class="comment"># 分别为前1项累加和， 前2项累加和......前n项累加和</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accmulate(numbers, min))</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accmulate(numbers, max))</span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h5 id="enumerate-it-start-0"><a href="#enumerate-it-start-0" class="headerlink" title="enumerate(it, start=0)"></a>enumerate(it, start=0)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> enumerate(range(<span class="number">3</span>), start=<span class="number">1</span>):</span><br><span class="line">···		print(<span class="string">"&#123;index&#125;---&#123;item&#125;"</span>.format(*i))</span><br><span class="line">···</span><br><span class="line"><span class="number">1</span>--<span class="number">-0</span></span><br><span class="line"><span class="number">2</span>--<span class="number">-1</span></span><br><span class="line"><span class="number">3</span>--<span class="number">-2</span></span><br></pre></td></tr></table></figure>

<h5 id="map-func-it-it2-it3……"><a href="#map-func-it-it2-it3……" class="headerlink" title="map(func, it, [it2, it3……])"></a>map(func, it, [it2, it3……])</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(operator.mul, range(<span class="number">10</span>), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h5 id="startmap-func-it"><a href="#startmap-func-it" class="headerlink" title="startmap(func, it)"></a>startmap(func, it)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(starmap(operator.mul, [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">4</span>)]))</span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>对于starmap而言，参数it的元素也必须是可迭代的。</p>
<h4 id="合并多个可迭代对象的生成器"><a href="#合并多个可迭代对象的生成器" class="headerlink" title="合并多个可迭代对象的生成器"></a>合并多个可迭代对象的生成器</h4><table>
<thead>
<tr>
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>itertools</td>
<td>chain(it1,…itN)</td>
<td>先产出it1中的元素，在产出it2中的元素，直到itN， 无缝衔接</td>
</tr>
<tr>
<td>itertools</td>
<td>chain.from_iterable(it)</td>
<td>it产出的元素是可迭代的，将其中的元素依次迭代出来，无缝衔接</td>
</tr>
<tr>
<td>itertools</td>
<td>product(it1,…itN, repeat=1)</td>
<td>计算笛卡尔积，与for循环嵌套一样</td>
</tr>
<tr>
<td>内置</td>
<td>zip(it1, …, itN)</td>
<td>并行获取可迭代对象中的元素，并且以元祖的形式组合并返还，只要有一个对象停止迭代整个行为就停止</td>
</tr>
<tr>
<td>itertools</td>
<td>zip_longest(it1,…,itN)</td>
<td>与zip类似，不过停止的标准是迭代完最长的可迭代对象，空缺值由fillvalue填充</td>
</tr>
</tbody></table>
<h5 id="chain-it1-…-itN"><a href="#chain-it1-…-itN" class="headerlink" title="chain(it1, …, itN)"></a>chain(it1, …, itN)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(chain(enumerate([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'a'</span>), (<span class="number">1</span>, <span class="string">'b'</span>), (<span class="number">2</span>, <span class="string">'c'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(chain([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h5 id="chain-from-iter-it1-…-itN"><a href="#chain-from-iter-it1-…-itN" class="headerlink" title="chain.from_iter(it1, …, itN)"></a>chain.from_iter(it1, …, itN)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(chain.from_iterable(enumerate([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])))</span><br><span class="line">[<span class="number">0</span>, <span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'b'</span>, <span class="number">2</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(chain.from_iterable([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h5 id="zip-it1-…-itN"><a href="#zip-it1-…-itN" class="headerlink" title="zip(it1, …, itN)"></a>zip(it1, …, itN)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h5 id="zip-longest-it1-…-itN"><a href="#zip-longest-it1-…-itN" class="headerlink" title="zip_longest(it1, …, itN)"></a>zip_longest(it1, …, itN)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip_longest([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="literal">None</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip_longest([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], fillvalue=<span class="number">0</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">0</span>)]</span><br></pre></td></tr></table></figure>

<h5 id="product-it1-…-itN-repeat-1"><a href="#product-it1-…-itN-repeat-1" class="headerlink" title="product(it1, …, itN, repeat=1)"></a>product(it1, …, itN, repeat=1)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(product(<span class="string">'abc'</span>, range(<span class="number">2</span>)))</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">0</span>), (<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">0</span>), (<span class="string">'b'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">0</span>), (<span class="string">'c'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(set(product(range(<span class="number">3</span>), range(<span class="number">3</span>), range(<span class="number">3</span>))))</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(set(product(range(<span class="number">3</span>), repeat=<span class="number">3</span>)))</span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>

<h4 id="把输入的各个元素扩展成多个输出元素的生成器函数"><a href="#把输入的各个元素扩展成多个输出元素的生成器函数" class="headerlink" title="把输入的各个元素扩展成多个输出元素的生成器函数"></a>把输入的各个元素扩展成多个输出元素的生成器函数</h4><table>
<thead>
<tr>
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>itertools</td>
<td>combinations(it, out_len)</td>
<td>把it产出的out_len个元素组合在一起然后产出，不包含相同的元素</td>
</tr>
<tr>
<td>itertools</td>
<td>combinations_with_replacement(it, out_len)</td>
<td>与combinations大体相同，但是包含相同元素</td>
</tr>
<tr>
<td>itertools</td>
<td>count(start=0, step=0)</td>
<td>从start开始产出数字等差数列，差值是step</td>
</tr>
<tr>
<td>itertools</td>
<td>cycle(it)</td>
<td>从it中获取各个元素，存储其副本，按顺序循环不断的产出</td>
</tr>
<tr>
<td>itertools</td>
<td>permutations(it, out_len=None)</td>
<td>对it的元素进行out_len的全排列， 与combinations_with_replacement类似，但是强调顺序</td>
</tr>
<tr>
<td>itertools</td>
<td>repeat(item, [times,])</td>
<td>重复产生item，直到times次</td>
</tr>
</tbody></table>
<h5 id="combinations-it-out-len"><a href="#combinations-it-out-len" class="headerlink" title="combinations(it, out_len)"></a>combinations(it, out_len)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(combinations(<span class="string">'abc'</span>, <span class="number">2</span>))</span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'b'</span>), (<span class="string">'a'</span>, <span class="string">'c'</span>), (<span class="string">'b'</span>, <span class="string">'c'</span>)]</span><br></pre></td></tr></table></figure>

<h5 id="combinations-with-replacement-it-out-len"><a href="#combinations-with-replacement-it-out-len" class="headerlink" title="combinations_with_replacement(it, out_len)"></a>combinations_with_replacement(it, out_len)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(combinations_with_replacement(<span class="string">'abc'</span>, <span class="number">2</span>))</span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'a'</span>), (<span class="string">'a'</span>, <span class="string">'b'</span>), (<span class="string">'a'</span>, <span class="string">'c'</span>), (<span class="string">'b'</span>, <span class="string">'b'</span>), (<span class="string">'b'</span>, <span class="string">'c'</span>), (<span class="string">'c'</span>, <span class="string">'c'</span>)]</span><br></pre></td></tr></table></figure>

<h5 id="count-start-0-step-0"><a href="#count-start-0-step-0" class="headerlink" title="count(start=0, step=0)"></a>count(start=0, step=0)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(itertools.count(start=<span class="number">3</span>, step=<span class="number">6</span>), <span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line">[<span class="number">9</span>, <span class="number">15</span>, <span class="number">21</span>]</span><br></pre></td></tr></table></figure>
<p>count()如果不加参数，直接list()初始化，那么就会无限重复下去</p>
<h5 id="cycle-it"><a href="#cycle-it" class="headerlink" title="cycle(it)"></a>cycle(it)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> cycle(<span class="string">"abc"</span>):</span><br><span class="line">··· 	print(item)</span><br><span class="line">···</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">...... <span class="comment"># 一直重复</span></span><br></pre></td></tr></table></figure>

<h5 id="permutations-it-out-len"><a href="#permutations-it-out-len" class="headerlink" title="permutations(it, out_len)"></a>permutations(it, out_len)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(permutations(<span class="string">'abc'</span>, <span class="number">2</span>))</span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'b'</span>), (<span class="string">'a'</span>, <span class="string">'c'</span>), (<span class="string">'b'</span>, <span class="string">'a'</span>), (<span class="string">'b'</span>, <span class="string">'c'</span>), (<span class="string">'c'</span>, <span class="string">'a'</span>), (<span class="string">'c'</span>, <span class="string">'b'</span>)]</span><br></pre></td></tr></table></figure>
<p>permutations与combinations_with_replacement看起来有点儿类似，但是后者是顺序产生的，不会出现‘ba’这样的元素，而permutations更类似于不重复的全排列。</p>
<h5 id="repeat-item-times"><a href="#repeat-item-times" class="headerlink" title="repeat(item, times)"></a>repeat(item, times)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(repeat(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="重新排列元素的生成器"><a href="#重新排列元素的生成器" class="headerlink" title="重新排列元素的生成器"></a>重新排列元素的生成器</h4><table>
<thead>
<tr>
<th>模块</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>itertools</td>
<td>groupby(it, key=None)</td>
<td>产生的元素形式如(key, group)， 其中key是group的分组依据， group就是分的组</td>
</tr>
<tr>
<td>itertools</td>
<td>tee(it, n=2)</td>
<td>产生一个有n个it组成的元组</td>
</tr>
<tr>
<td>内置</td>
<td>reversed(seq)</td>
<td>反转，对象必须是序列，或者实现了__reversed__</td>
</tr>
</tbody></table>
<h5 id="groupby-it-key-None"><a href="#groupby-it-key-None" class="headerlink" title="groupby(it, key=None)"></a>groupby(it, key=None)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, it <span class="keyword">in</span> groupby(<span class="string">'zzmmoozz'</span>):</span><br><span class="line">···		print(key, list(it))</span><br><span class="line">···</span><br><span class="line">z [<span class="string">'z'</span>, <span class="string">'z'</span>]</span><br><span class="line">m [<span class="string">'m'</span>, <span class="string">'m'</span>]</span><br><span class="line">o [<span class="string">'o'</span>, <span class="string">'o'</span>]</span><br><span class="line">z [<span class="string">'z'</span>, <span class="string">'z'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, it <span class="keyword">in</span> groupby(<span class="string">'mmoozzzz'</span>):</span><br><span class="line">···		print(key, list(it))</span><br><span class="line">···</span><br><span class="line">m [<span class="string">'m'</span>, <span class="string">'m'</span>]</span><br><span class="line">o [<span class="string">'o'</span>, <span class="string">'o'</span>]</span><br><span class="line">z [<span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>]</span><br></pre></td></tr></table></figure>
<p>使用groupby之前，经可能的先排序，groupby是从前向后找，不回头。</p>
<h5 id="tee-it-n-2"><a href="#tee-it-n-2" class="headerlink" title="tee(it, n=2)"></a>tee(it, n=2)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> tee([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]):</span><br><span class="line">···		print(list(item))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h5 id="reversed-seq"><a href="#reversed-seq" class="headerlink" title="reversed(seq)"></a>reversed(seq)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"123456"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(reversed(a))</span><br><span class="line">···	<span class="string">"654321"</span></span><br></pre></td></tr></table></figure>

<h2 id="iter函数其它的用途"><a href="#iter函数其它的用途" class="headerlink" title="iter函数其它的用途"></a>iter函数其它的用途</h2><p>除了获取可迭代对象的迭代器之外，iter函数还有其他的用途<br>当iter接受两个参数的时候，第一个参数必须是可调用对象，用于不断的调用（没有参数值），第二个是标记值，当第一个参数的返回值等于标记值的时候，iter结束自身行为。<br>以下场景：通过randint函数来模拟掷骰子，不管扔多少次，仍到6就停止。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">get_six</span><span class="params">()</span>:</span></span><br><span class="line">···		<span class="keyword">return</span> random.randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">···</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> item <span class="keyword">in</span>  iter(get_six, <span class="number">6</span>):</span><br><span class="line">···		print(item)</span><br><span class="line">···</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>由于get_six的返回值为6的时候，iter函数的行为就终止了，所以并不会将数值6打印出来<br>iter官方介绍用例的时候，使用的是读取文件的案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filePath) <span class="keyword">as</span> f:</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> iter(f.readline, <span class="string">"\n"</span>):</span><br><span class="line">		process_line(line)</span><br></pre></td></tr></table></figure>
<p>打开文件后，逐行读取文件，直到遇到空行或者文件结束为止。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>迭代器</tag>
        <tag>生成器</tag>
        <tag>可迭代对象</tag>
      </tags>
  </entry>
  <entry>
    <title>yield与协程</title>
    <url>/2020/03/28/yield%20%E4%B8%8E%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="进程、线程与协程"><a href="#进程、线程与协程" class="headerlink" title="进程、线程与协程"></a>进程、线程与协程</h2><p>一般来说，进程是操作系统分配资源的最小单元；线程是操作系统进行调度的最小单元。而协程则相对不同，协程也拥有自己的独立的上下文，并且协程的切换由自己来控制。<br>与线程相比，协程避免了无意义的调度，此方面可以提升一定的性能。同时，由于需要程序自身完成调度，协程也失去了标准线程使用多CPU的能力。</p>
<a id="more"></a>
<h2 id="Python的生成器函数与协程"><a href="#Python的生成器函数与协程" class="headerlink" title="Python的生成器函数与协程"></a>Python的生成器函数与协程</h2><p>在Python中，含有yield关键字的函数被称之为生成器函数。<br>在Python2.5之后，对生成器函数实现了.send()方法。该方法与__next__类似，可以使得生成器前进到下一个yield点，同时，.send()函数还允许调度方将数据作为参数返还给自身。也就是说，.send()方法允许调度方与生成器之间双向交换数据。<br>这种改进极大的改变了生成器的本质。如果像是这样使用的话，生成器本省就变成了协程。但是，生成器和协程从使用角度来说，还是有不同之处的：</p>
<ul>
<li>生成器用于生成供以迭代的数据，是产生数据的一方，并不需要额外的从调度方回收数据。</li>
<li>协程则是数据的消费者，一般来说，是由调度方将数据传递到协程供协程加工。</li>
<li>协程是与迭代无关的。</li>
</ul>
<p>yield关键字可以不接受和传出数据，但是不管数据是如何流动的，yield都只是一种控制流程的工具。从根本上把yield视作是控制流程的方式，这样可能更加有利于理解协程。<br>协程指的是一个过程，这个过程与调度方协作，产出由调度方提供的值。</p>
<h2 id="基本的协程"><a href="#基本的协程" class="headerlink" title="基本的协程"></a>基本的协程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"coroutine start!"</span>)</span><br><span class="line">	data = <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line">	print(<span class="string">"received data &#123;&#125;"</span>.format(data))</span><br><span class="line"></span><br><span class="line">cor = simple_coroutine()                        <span class="comment"># 创建一个协程</span></span><br><span class="line">d = next(cor)                                   <span class="comment"># 催动协程到第一个yield控制点</span></span><br><span class="line">print(d)                                        <span class="comment"># 接受由yield返还的数据</span></span><br><span class="line">cor.send(<span class="number">100</span>)                                   <span class="comment"># 接下来由send函数驱动协程到下一个yield控制点，同时将参数传递到协程，由于没有yield，会抛出StopIteration异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">coroutine start!</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">received data 100</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "/Users/livis/Desktop/notes/format_demo.py", line 77, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    cor.send(100)                                   # 接下来由send函数驱动协程到下一个yield控制点，同时将参数传递到协程，由于没有yield，会抛出StopIteration异常</span></span><br><span class="line"><span class="string">StopIteration</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>如果协程处于等待开始执行的状态，则不能使用send。<br>协程大致可以分为四个状态，协程的当前状态可以由inspect模块中的getgeneratorstate()函数来获取，参数是协程变量，返还下述字符串中的一个：</p>
<ul>
<li>GEN_CREATED——协程被创建，但尚未开始。表示协程处于等待开始执行。</li>
<li>GEN_RUNNING——协程正在被执行。    </li>
<li>GEN_SUSPENDED——协程在yield表达式处暂停。</li>
<li>GEN_CLOSED——协程已被关闭，执行结束。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">()</span>:</span></span><br><span class="line">	total = <span class="number">0</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	average = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		data = <span class="keyword">yield</span> average</span><br><span class="line">		total += data</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">		average = total / count</span><br><span class="line">		</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ave.send(<span class="number">3</span>)					<span class="comment"># 没有激活的协程直接使用send()会抛出异常。</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can<span class="string">'t send non-None value to a just-started generator</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; ave = average()				# 获取协程对象</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; next(ave)					# 激活协程</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;	ave.send(10)					# 求取第一次平均值</span></span><br><span class="line"><span class="string">10.0</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; ave.send(20)				# 求取第二次平均值</span></span><br><span class="line"><span class="string">15.0</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; ave.send(3)					# 求取第三次平均值</span></span><br><span class="line"><span class="string">11.0</span></span><br></pre></td></tr></table></figure>
<p>上述例子展示了如何使用协程来计算一个动态的平均值。在协程没有被next函数激活的情况下，直接使用send函数会报错。</p>
<h3 id="协程的终止以及异常处理"><a href="#协程的终止以及异常处理" class="headerlink" title="协程的终止以及异常处理"></a>协程的终止以及异常处理</h3><p>协程中未处理的异常会导致协程终止。传递给协程的调度方。而调度方也可以显示的将异常发送给协程，这两个方法是throw和close。</p>
<ul>
<li>throw方法会导致生成器在暂停的yield表达式处抛出指定的异常，如果生成器处理了相关的异常，则代码继续执行到下一个yield，此时的yield的返回值会作为调用throw()方法的接受值。如果无法处理相关异常，则异常会向上冒泡，回到调用方的上下文中。</li>
<li>close方法会在生成器内部暂停的yield处抛出指定的GeneratorExit异常，如果生成器没有处理，或者是生成器抛出了StopIteration，协程的调度方不会报错，而是直接终止。然后如果说生成器处理了该异常，那么就一定不能有返回值，否则会抛出RuntimeError异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyException</span><span class="params">(Exception)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gene</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    index = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> index:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> <span class="string">"&#123;&#125;data"</span>.format(index)</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'&#123;&#125;ok'</span>.format(index))</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> MyException:</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">"get my exception!"</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> e</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>            index += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gene()						<span class="comment"># 创建协程对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)							<span class="comment"># 激活协程</span></span><br><span class="line"><span class="string">'1data'</span>								<span class="comment"># 激活协程时候第一次返回的数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.throw(MyException())			<span class="comment"># 通过throw传递MyException进入协程内部</span></span><br><span class="line">get my exception!					<span class="comment"># 被第一个Except子语句捕获</span></span><br><span class="line"><span class="string">'2data'</span>								<span class="comment"># 协程内部处理之后接着走到第二个yield地方</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)							<span class="comment"># 传递的错误如果被协程内部处理，则不影响协程运行</span></span><br><span class="line"><span class="number">2</span>ok	</span><br><span class="line"><span class="string">'3data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.throw(Exception())				<span class="comment"># 抛入一个不被处理的错误类型</span></span><br><span class="line">Traceback (most recent call last):		<span class="comment"># 引发错误栈</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">10</span>, <span class="keyword">in</span> gene</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> gene</span><br><span class="line">Exception</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)							<span class="comment"># 协程已经被终止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2 = gene()						<span class="comment"># 再次创建个新的协程对象并激活</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g2)</span><br><span class="line"><span class="string">'1data'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g2.close()						<span class="comment"># 使用close关闭协程</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g2)							<span class="comment"># 关闭后的协程已经被终止</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="协程通过return返回值"><a href="#协程通过return返回值" class="headerlink" title="协程通过return返回值"></a>协程通过return返回值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gene</span><span class="params">()</span>:</span>							</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">"this is yield！"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"this is return！"</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gene()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="string">'this is yield!'</span>								<span class="comment"># 第一次调用，生成器输出的是yield后面的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">Traceback (most recent call last):				<span class="comment"># 再次启动生成器，抛出StopIteration异常，注意异常的内容说明，与return的一样。</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration: this <span class="keyword">is</span> <span class="keyword">return</span>!</span><br></pre></td></tr></table></figure>
<p>通过上述例子可以来看出，return返还的内容像是被StopIteration接受了。下面尝试使用try/exxcept来捕捉异常并输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gene</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> MyObject()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gene()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    next(g)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    res = e.value</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">&lt;__main__.MyObject object at <span class="number">0x101155da0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>协程的返回值被StopIteration的value所保存。</p>
<h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><p>yield from 是一种全新的语言结构，它的作用会比yield多很多。<br>在其他的育秧中，类似的结构使用await关键字比较多。这个名称比较容易理解，因为它传递了至关重要的一点，在生成器gen中使用yield from subgen()的时候，subgen()会获取程序的控制权，把产出的值传给gen的调度方。<br>也就是说调度方可以直接控制subgen()，与此同时，gen会阻塞等待，等待subgen的终止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"abc"</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> i</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> j</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen())</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen2</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">"abc"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen2())</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>上例子表示使用yield可以简化for循环中的yield表达式。<br>除此之外，在说明标准库生成器函数的时候，又一个chain函数，作用是为元素为可迭代对象的可迭代对象拆包，可以写成下面的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterators)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> it <span class="keyword">in</span> iterators:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> chain(<span class="string">"abc"</span>, range(<span class="number">3</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="关于yield-from-表达式的一些说明"><a href="#关于yield-from-表达式的一些说明" class="headerlink" title="关于yield from 表达式的一些说明"></a>关于yield from 表达式的一些说明</h3><p>对于 <strong>yield from x</strong> 表达式，对对象x所做的第一个操作是取出对象x的迭代器，即iter(x)。<br>下面将就一个例子详细说明yield from 对程序流程控制的影响，为了方便说明，首先解释一些术语：</p>
<ul>
<li>委派生成器    包含有yield from 表达式的生成器函数</li>
<li>子生成器    被yield from 表达式获取的生成器函数</li>
<li>调度方    调用委派生成器的程序代码</li>
</ul>
<blockquote>
<p>委派生成器在yield from 表达式处暂停后，调用方可以直接把数据发送到子生成器，而委派生成器并不知道数据。子生成器再将产出的值返回到调用方，委派方也不知道，当子生成器完全返回（被return）的时候，解释器抛出StopIteration异常，并将返回值附加到异常的value属性上。然后委派生成器再次开始运行。<br>委派生成器更像是一个调度方与子生成器交互数据的管道。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">subgen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    flag = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> flag:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"子生成器被执行-----&#123;&#125;"</span>.format(flag))</span><br><span class="line"><span class="meta">... </span>        flag = <span class="keyword">yield</span> <span class="number">123</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    flagMax = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> flagMax:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"委派生成器被执行"</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> <span class="keyword">from</span> subgen()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gen()			</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">委派生成器被执行</span><br><span class="line">子生成器被执行----<span class="number">-1</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">委派生成器被执行</span><br><span class="line">子生成器被执行----<span class="number">-1</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="number">10</span>)</span><br><span class="line">子生成器被执行----<span class="number">-10</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="number">100</span>)</span><br><span class="line">子生成器被执行----<span class="number">-100</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="number">0</span>)</span><br><span class="line">委派生成器被执行</span><br><span class="line">子生成器被执行----<span class="number">-1</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>首先定义类两个生成器，其中有一个是有yield from 结构的生成器，暂称之为委派生成器，另一个称之为子生成器。<br>第一步首先创建委派生成器对象，并将其激活。在这一步中可以看到委派生成器和子生成器的代码都执行了。<br>当再次使用next的时候，相当于执行委派生成器，重新创建了子生成器对象。 委派生成器代码和子生成器代码均执行。<br>但当使用send函数发生数据交互的时候，更像是调度方直接和子生成器进行了数据交互，委派生成器的代码像是没有执行。<br>通过send(0)，子生成器退出循环，返回None，同时抛出StopIteration异常，委派生成器再次开始运行，创建新的子生成器。</p>
<h3 id="yield-from-举一个实例"><a href="#yield-from-举一个实例" class="headerlink" title="yield from 举一个实例"></a>yield from 举一个实例</h3><p>从一个字典中读取虚构的七年级男女学生的身高和体重，生成一个报告。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">'Result'</span>, <span class="string">'count average'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the subgenerator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span>  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span>  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the delegating generator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span>  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()  <span class="comment"># &lt;7&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the client code, a.k.a. the caller</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span>  <span class="comment"># &lt;8&gt;</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)  <span class="comment"># &lt;9&gt;</span></span><br><span class="line">        next(group)  <span class="comment"># &lt;10&gt;</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value)  <span class="comment"># &lt;11&gt;</span></span><br><span class="line">        group.send(<span class="literal">None</span>)  <span class="comment"># important! &lt;12&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(results)  # uncomment to debug</span></span><br><span class="line">    report(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># output report</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span><span class="params">(results)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> sorted(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">';'</span>)</span><br><span class="line">        print(<span class="string">'&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;'</span>.format(</span><br><span class="line">              result.count, group, result.average, unit))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'girls;kg'</span>:</span><br><span class="line">        [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">'girls;m'</span>:</span><br><span class="line">        [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">'boys;kg'</span>:</span><br><span class="line">        [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">'boys;m'</span>:</span><br><span class="line">        [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(data)</span><br></pre></td></tr></table></figure>
<ol>
<li>此生成器作为<strong>子生成器</strong>使用。</li>
<li>调度方代码<strong>发送的值绑定到item变量</strong>。</li>
<li>至关重要的终止条件，子生成器通过调度方发送的数据来跳出循环。如果不这么做，使用yield from的这个生成器将会永远阻塞。</li>
<li>返还的结果将成为<strong>委托生成器函数中yield from 表达式的值</strong>。</li>
<li>委派生成器。</li>
<li>委派生成器中，循环每次迭代都换新建子生成器对象，每个对象都做协程使用。</li>
<li>grouper发送的值都会经由yield from 传递到average对象处理，grouper会在yield from处暂停。当average运行结束返回值的时候，将值绑定到result上。然后再次迭代。</li>
<li>调度方。</li>
<li>获取生成器对象。</li>
<li>预激生成器对象。</li>
<li>将value传递到average，传递的值最终到term = yield 那一行。  </li>
<li>将None传入average，导致average跳出循环，终止，染grouper继续运行，创建下一个average实例，处理下一组值。</li>
</ol>
<h2 id="使用协程做离散事件仿真"><a href="#使用协程做离散事件仿真" class="headerlink" title="使用协程做离散事件仿真"></a>使用协程做离散事件仿真</h2><blockquote>
<p>离散事件仿真是一种把系统建模成一系列事件的仿真类型。<br>在离散事件中，时刻向前推进的量是不一定的，假想时间是一条轴，事件发生的时间是轴上的一个个时间节点。<br>只要逐步推进轴上的节点，就能在很短的时间内模拟很长时间的事件发生情况。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建事件类，只需要有属性，所以namedtuple即可 一共有四种事件action，分别是leave garage；pick off，drop off; going home</span></span><br><span class="line">Event = namedtuple(<span class="string">"Event"</span>, [<span class="string">'time'</span>, <span class="string">'proc'</span>, <span class="string">'action'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taxi_process</span><span class="params">(taxiId, trips, startTime=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用于产生出租车的各项事件</span></span><br><span class="line"><span class="string">    首先产生 leave garage 事件</span></span><br><span class="line"><span class="string">    程序挂起</span></span><br><span class="line"><span class="string">    时间轴推进的时候再次启动程序，同时传递参数time1</span></span><br><span class="line"><span class="string">    接下来循环接送乘客：</span></span><br><span class="line"><span class="string">        产生接乘客事件，暂停</span></span><br><span class="line"><span class="string">        激活 返回下乘客时间，返回下乘客事件，挂起</span></span><br><span class="line"><span class="string">        激活，返回接乘客时间， 返回接乘客时间， 挂起</span></span><br><span class="line"><span class="string">        ......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    leaveTime标记离开时间</span></span><br><span class="line"><span class="string">    最后返回回家事件</span></span><br><span class="line"><span class="string">    然后抛出StopIteration</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time1 = <span class="keyword">yield</span> Event(startTime, taxiId, <span class="string">'leave garage'</span>)</span><br><span class="line">    </span><br><span class="line">    leaveTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(trips):</span><br><span class="line">        time1 = <span class="keyword">yield</span> Event(time1, taxiId, <span class="string">'pick up passenger'</span>)</span><br><span class="line">        time1 = <span class="keyword">yield</span> Event(time1, taxiId, <span class="string">'drop off passenger'</span>)</span><br><span class="line"></span><br><span class="line">        leaveTime = time1</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> Event(leaveTime, taxiId, <span class="string">'going home'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simulator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, procsMap)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        数据保存激活的协程映射 形如&#123;出租车ID：对应的事件生成器&#125;</span></span><br><span class="line"><span class="string">        queue.PriorityQueue 优先级队列，会为置入的元素排序（二叉树）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._procsMap = dict(procsMap)</span><br><span class="line">        self._events = queue.PriorityQueue()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, endTime)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行函数, endTime为结束仿真模拟测试的时刻</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将所有事件按键排序， 预激活协程，获取离开车库事件， 将事件加入队列</span></span><br><span class="line">        <span class="keyword">for</span> taxiId, process <span class="keyword">in</span> sorted(self._procsMap.items()):</span><br><span class="line">            leaveEven = next(process)</span><br><span class="line">            self._events.put(leaveEven)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 仿真事件主循环</span></span><br><span class="line">        simTime = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> simTime &lt; endTime:</span><br><span class="line">            <span class="comment"># 队列里面事件空了，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> self._events.empty():</span><br><span class="line">                print(<span class="string">"---end events---"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取队列里时刻最近的 出租车事件， 并对namedtuple拆包, 然后输出事件</span></span><br><span class="line">            curEvent = self._events.get()</span><br><span class="line">            simTime, procId, action = curEvent</span><br><span class="line">            print(<span class="string">'taxi:&#123;&#125;&#123;&#125;'</span>.format(procId, procId*<span class="string">'\t'</span>), curEvent)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从映射中获取当前激活的协程</span></span><br><span class="line">            activeProc = self._procsMap.get(procId)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取下一次的时刻</span></span><br><span class="line">            nextTime = simTime + compute_duration(action)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 驱动响应的协程</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                event = activeProc.send(nextTime)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">del</span> self._procsMap[procId]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._events.put(event)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 到了截止时间 队列尚有事件尚未输出</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'---end of simulator time, &#123;&#125; events pending!'</span>.format(self._events.qsize()))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_duration</span><span class="params">(action)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> action <span class="keyword">in</span> [<span class="string">'leave garage'</span>, <span class="string">'drop off passenger'</span>]:</span><br><span class="line">        <span class="comment"># new state is prowling</span></span><br><span class="line">        interval = <span class="number">5</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">'pick up passenger'</span>:</span><br><span class="line">        <span class="comment"># new state is trip</span></span><br><span class="line">        interval = <span class="number">20</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">'going home'</span>:</span><br><span class="line">        interval = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Unknown previous_action: %s'</span> % action)</span><br><span class="line">    <span class="keyword">return</span> int(random.expovariate(<span class="number">1</span>/interval)) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(endTime)</span>:</span></span><br><span class="line">    taxis = &#123;</span><br><span class="line">        _id: taxi_process(_id, (_id+<span class="number">1</span>)*<span class="number">2</span>, _id*<span class="number">5</span>) <span class="keyword">for</span> _id <span class="keyword">in</span> range(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = Simulator(taxis)</span><br><span class="line">    s.run(endTime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main(<span class="number">150</span>)</span><br></pre></td></tr></table></figure>

<h2 id="新的关键字"><a href="#新的关键字" class="headerlink" title="新的关键字"></a>新的关键字</h2><p>Python 3.5以后，出现了新的关键子，async/await</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>协程</tag>
        <tag>yield</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2019/04/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式之工厂"><a href="#设计模式之工厂" class="headerlink" title="设计模式之工厂"></a>设计模式之工厂</h2><p>如果说单例模式是最简单的设计模式，那么工厂模式应该是最常见的设计模式之一。我们会在各种各样的地方看见使用工厂模式的痕迹。工厂模式也是属于创建类型，在工厂模式中，们在创建对象时不会对客户端（不是CS建构中的C，一般是指使用工厂的一方）暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>简单来说，就是使用者不关心其实现，而关心其结果和使用。</p>
<p>工厂模式背后的思想是简化对象的创建。与客户端自己基于类实例化直接创建对象相比，基于一个中心化函数来实现，更易于追踪创建了哪些对象。通过将创建对象的代码和使用对象的代码解耦，工厂能够降低应用维护的复杂度。</p>
<p>工厂模式，很好的体现了设计原则中的开放封闭原则。</p>
<a id="more"></a>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>对于数据库的访问，在客户端使用之前，我们并不知道客户端将基于何种数据库链接，有肯能是MySQL，有可能是MongoDB，也可能其它。具体会用哪一种，完全依赖于用户的输入/配置项。而客户端不关心我们的连接的具体实现。</li>
<li>记得有段时间不少app推出夜间模式和白天模式，用户输入的仅仅是白天/夜间。而app从展现的内容到推送的消息完全不一样，这也是工厂模式的一种应用。</li>
</ol>
<h2 id="简单的工厂模式"><a href="#简单的工厂模式" class="headerlink" title="简单的工厂模式"></a>简单的工厂模式</h2><p>在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>作为一个人，吃饭是我的本能；而作为一个中国人，我吃饭口味的选择就很多。我可能想吃川菜、粤菜、湘菜等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook_cc</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u chuan cai"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook_yc</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u yue cai"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook_xc</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u xiang cai"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eating......"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.cook_cc()</span><br><span class="line">        self.eat()</span><br></pre></td></tr></table></figure>
<p>上述代码描述了我在吃川菜，那么会出现一种情况，我第二天不想吃川菜了，我想吃的是粤菜，那么我就要修改代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.cook_yc()</span><br><span class="line">    self.eat()</span><br></pre></td></tr></table></figure>
<p>看似好像解决了，可是如果我第三天想吃的是湘菜，第四天又回过头想吃粤菜了…..无穷无尽的修改。作为一个懒惰的码农，是绝对不能允许这种事情发生的。于是将上面的代码彻底改一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook_cc</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u chuan cai"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook_yc</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u yue cai"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook_xc</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u xiang cai"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eating......"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self, flavour)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> flavour == <span class="string">"cc"</span>:</span><br><span class="line">            self.cook_cc()</span><br><span class="line">        <span class="keyword">elif</span> flavour == <span class="string">"yc"</span>:</span><br><span class="line">            self.cook_yc()</span><br><span class="line">        <span class="keyword">elif</span> flavour == <span class="string">"xc"</span>:</span><br><span class="line">            self.cook_xc()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">"undefine flavour"</span></span><br><span class="line">        self.eat()</span><br></pre></td></tr></table></figure>
<p>给eat()添加了参数，这下每天只要告诉自己喜欢什么口味，自己再去做相应的口味就行了。</p>
<p>等等，自己做？我是一个码农，做饭并不是我擅长的事情，专业的事情要交给专业的人做，做饭的事情，当然还是交给厨子好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuanCooker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u chuan cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YueCooker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u yue cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiangCooker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u xiang cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eating......"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self, flavour)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> flavour == <span class="string">"cc"</span>:</span><br><span class="line">            cooker = ChuanCooker()</span><br><span class="line">        <span class="keyword">elif</span> flavour == <span class="string">"yc"</span>:</span><br><span class="line">            cooker = YueCooker()</span><br><span class="line">        <span class="keyword">elif</span> flavour == <span class="string">"xc"</span>:</span><br><span class="line">            cooker = XiangCooker()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">"undefine flavour"</span></span><br><span class="line">        cooker.cook()</span><br><span class="line">        self.eat()</span><br></pre></td></tr></table></figure>
<p>现在，我们将做饭这件事情从我们身上剥离出去了，交给了专业的厨师来做。这只是极端情况下的模拟，真实的场景可能要复杂的多，比如厨师，不管是哪里的厨师，cook前都要买菜，洗菜，他们可能还要和助手交流，这些都是他们的共性，我们可以将这个共性厨师身上剥离出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCooker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"xi cai"</span>)</span><br><span class="line">    </span><br><span class="line">    ......共性方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuanCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u chuan cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YueCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u yue cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiangCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u xiang cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eating......"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self, flavour)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> flavour == <span class="string">"cc"</span>:</span><br><span class="line">            cooker = ChuanCooker()</span><br><span class="line">        <span class="keyword">elif</span> flavour == <span class="string">"yc"</span>:</span><br><span class="line">            cooker = YueCooker()</span><br><span class="line">        <span class="keyword">elif</span> flavour == <span class="string">"xc"</span>:</span><br><span class="line">            cooker = XiangCooker()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">"undefine flavour"</span></span><br><span class="line">        cooker.cook()</span><br><span class="line">        self.eat()</span><br></pre></td></tr></table></figure>
<p>这样看起来好多了。每次吃饭前我只需要想好要吃什么，再由我的口味去挑选相应的厨师就行了。可是我好像对于挑选厨师也不是很在行，干脆这件事情也交给其他人算了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCooker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"xi cai"</span>)</span><br><span class="line"></span><br><span class="line">    ......共性方法</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuanCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u chuan cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YueCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u yue cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiangCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u xiang cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickCooker</span><span class="params">(flavour)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> flavour == <span class="string">"cc"</span>:</span><br><span class="line">            cooker = ChuanCooker()</span><br><span class="line">        <span class="keyword">elif</span> flavour == <span class="string">"yc"</span>:</span><br><span class="line">            cooker = YueCooker()</span><br><span class="line">        <span class="keyword">elif</span> flavour == <span class="string">"xc"</span>:</span><br><span class="line">            cooker = XiangCooker()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">"undefine flavour"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cooker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eating......"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self, flavour)</span>:</span></span><br><span class="line">        cooker = Restaurant.pickCooker(flavour)</span><br><span class="line">        cooker.cook()</span><br><span class="line">        self.eat()</span><br></pre></td></tr></table></figure>
<p>OK，我们终于将多余的事情都甩出去了，剩下的就是想好每天吃什么，然后我们告诉餐厅我们的口味，至于挑选哪个厨子的事情，这不是我们吃饭的人应该操心的。</p>
<h3 id="角色对应"><a href="#角色对应" class="headerlink" title="角色对应"></a>角色对应</h3><p>到此为止，我们就算实现了简单工厂模式。简单工厂模式的实现需要三个角色：</p>
<ul>
<li>工厂类角色：这是简单工厂模式的核心角色。含有与应用紧密相关的业务逻辑，工厂类在客户端的调用下，根据传入参数不同，返回不同的产品对象。<blockquote>
<p>在这个例子中，<strong>餐厅Restaurant对应着工厂类角色</strong></p>
</blockquote>
</li>
<li>抽象产品角色：这个角色一般是产品的基类，或者说是父类。一般来说，这个类都是个抽象类。抽象是一个很抽象的概念，为了便于理解，我们在这个地方暂且不管吧。<blockquote>
<p>在这个例子中， <strong>厨师基类BaseCooker对应着从抽象产品角色</strong></p>
</blockquote>
</li>
<li>具体产品角色：这应该是最好理解的一个角色，就是工厂类实例化的对象，不管是哪个类实例化的，都是具体产品角色。<blockquote>
<p>在这个例子中， <strong>在餐厅中实现的各种厨师对象，就是具体产品角色</strong></p>
</blockquote>
</li>
</ul>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><ul>
<li>优点：<ul>
<li>将判断逻辑移植到工厂类中，从而免除了客户端对于生产对象的职责，实现责任分离：即客户端消费产品，工厂根据客户需求生产产品。</li>
<li>对于客户端而言，无需知道到底能不能实现该产品，只需要知道产品的参数，能不能实现，怎么实现交给工厂。</li>
<li>如果后期添加产品种类，修改的是工厂类的代码，而客户端的代码完全不需要改动。单从产品的角度来说，符合设计原则中的开放封闭原则。</li>
</ul>
</li>
<li>缺点：<ul>
<li>工厂类与整个代码而言，是强耦合的，由于所有的产品对象都是工厂类完成的，一段工厂类发生异常，整个业务逻辑都会受到波及。</li>
<li>一旦产品种类增加的很多，对于工厂类而言，判断逻辑过多，整个代码会显得很臃肿，不利于代码的后续扩展和维护。</li>
</ul>
</li>
</ul>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>在工厂方法模式中，不再有单一的工厂生产产品。会将工厂类也抽象出来。工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>故事线继续发展。</p>
<p>在上一段故事中，我们吃饭的人貌似爽了，不爽的是餐馆了。随着我们的口味越来越奇怪，他们不得不招各种各样的厨子来满足我们（厨子的类要一直添加）。每次增加厨子菜单都要改写（添加elif判断）。终于有一天，餐馆忙中出错，菜单写错了，客人要的是闽菜MC，餐馆却让做徽菜WC的厨子上菜了。客人受不了被辣死了，餐馆被查封，这下所有的食客都吃不了饭了。</p>
<p>有没有什么办法能够既满足众人的口味，又减轻餐馆的负担？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCooker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"xi cai"</span>)</span><br><span class="line"></span><br><span class="line">    ......共性方法</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRestaurant</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receiptOfPayment</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get customer cash!"</span>)</span><br><span class="line"></span><br><span class="line">    ......共性方法</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCooker</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuanCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u chuan cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YueCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u yue cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiangCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u xiang cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuanRestaurant</span><span class="params">(BaseRestaurant)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCooker</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ChuanCooker()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YueRestaurant</span><span class="params">(BaseRestaurant)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCooker</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> YueCooker()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiangRestaurant</span><span class="params">(BaseRestaurant)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCooker</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> XiangCooker()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eating......"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self, restaurantName)</span>:</span></span><br><span class="line">        cooker = eval(restaurantName)().getCooker()</span><br><span class="line">        cooker.cook()</span><br><span class="line">        self.eat()</span><br></pre></td></tr></table></figure>
<p>群众的力量是强大的，在大家的集思广益下，终于相处了一个好的办法：做特色菜馆！粤菜馆专门做粤菜，川菜馆专门做川菜，湘菜馆专门做湘菜……这样一来，虽然食客的口味是多样的，但是由于一家菜馆只做一种口味的菜。当用户口味再增加的时候，只需要在建立一个菜馆，菜馆里在招一个厨师就行了，之前的菜馆根本不用动。这样就算其中一个菜馆倒闭了，但是不影响其它口味的食客正常就餐！</p>
<p>而作为食客，我只需要知道餐馆的名字就行了。食客需要做的事情，找到适合自己口味的餐馆，吃饭。</p>
<blockquote>
<p>备注：为了减少代码示例量，所以在restaurant的getCooker方法就是简单的生成对象。而在实际中，不是简简单单的这一行代码就，可能会有给厨师配置各种各样的厨具对象等等。</p>
</blockquote>
<h3 id="角色对应-1"><a href="#角色对应-1" class="headerlink" title="角色对应"></a>角色对应</h3><p>在工厂方法模式中，比简单工厂多了一种角色，或者更确切的说法是，将简单工厂模式中的工厂类角色拆分，拆分成为抽象工厂类和具体工厂类：</p>
<ul>
<li>抽象工厂类角色：这是工厂方法模式的核心角色。和业务逻辑无关。<blockquote>
<p>在这个例子中，<strong>餐厅基类BaseRestaurant对应着抽象工厂类角色</strong></p>
</blockquote>
</li>
<li>具体工厂类角色：担任这个角色的是实现了抽象工厂接口的类。具体工厂角色含有与应用密切相关的逻辑，并且受到应用程序的调用以创建产品对象。<blockquote>
<p>在这个例子中， <strong>餐厅的实现，对应具体工厂类角色</strong></p>
</blockquote>
</li>
<li>抽象产品角色：和简单工厂模式一样。<blockquote>
<p>在这个例子中， <strong>厨师基类BaseCooker对应着从抽象产品角色</strong></p>
</blockquote>
</li>
<li>具体产品角色：和简单工厂模式一样。<blockquote>
<p>在这个例子中， <strong>在餐厅中实现的各种厨师对象，就是具体产品角色</strong></p>
</blockquote>
<h3 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h3></li>
<li>优点：<ul>
<li>在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模</li>
</ul>
</li>
<li>缺点：<ul>
<li>现在一旦增加产品，要同时实现具体产品类和具体工厂类，系统复杂度直线上升。</li>
</ul>
</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式是对工厂方法模式的进一步演化。其定义是：提供一个创建<strong>一系列相关或相互依赖对象</strong>的接口，而无须指定它们具体的类。在前面的简单工厂模式和工厂方法模式中，我们都是对一个对象的获取，而在抽象工厂模式中，变成了一系列相关的对象。</p>
<p>这里面有两个关键词，一个是<strong>系列</strong>一个是<strong>相互依赖</strong>。简单来说，抽象工厂模式能提供一堆对象，这一堆对象之间是有相互关系的。我们举个例子说明</p>
<p>在前面的代码演示中，我们通过工厂方法模式，演变出了食客找餐馆，餐馆负责招厨师，厨师生产食物的过程，其实吃饭不是一件独立能完成的事情，还需要很多很多的辅助。比如说我们把食物放到嘴里，是需要餐具的，而每个地方菜的餐具都是有其特色的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCooker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wash</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"xi cai"</span>)</span><br><span class="line"></span><br><span class="line">    ......共性方法</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRestaurant</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receiptOfPayment</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get customer cash!"</span>)</span><br><span class="line"></span><br><span class="line">    ......共性方法</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCooker</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuanCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u chuan cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YueCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u yue cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiangCooker</span><span class="params">(BaseCooker)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cook</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"gei u xiang cai"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTableware</span><span class="params">(object)</span>:</span></span><br><span class="line">    ......共性方法</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">takeFood</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuanTableware</span><span class="params">(BaseTableware)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">takeFood</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"take chuan food"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YueTableware</span><span class="params">(BaseTableware)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">takeFood</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"take yue food"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiangTableware</span><span class="params">(BaseTableware)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">takeFood</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"take xiang food"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChuanRestaurant</span><span class="params">(BaseRestaurant)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCooker</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ChuanCooker()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTableware</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ChuanTableware()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YueRestaurant</span><span class="params">(BaseRestaurant)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCooker</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> YueCooker()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTableware</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> YueTableware()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiangRestaurant</span><span class="params">(BaseRestaurant)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCooker</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> XiangCooker()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getTableware</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> XiangTableware()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eating......"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(self, restaurantName)</span>:</span></span><br><span class="line">        cur = eval(restaurantName)()</span><br><span class="line"></span><br><span class="line">        cooker = cur.getCooker()</span><br><span class="line">        tableware = cur.getTableware()</span><br><span class="line"></span><br><span class="line">        cooker.cook()</span><br><span class="line">        self.eat()</span><br></pre></td></tr></table></figure>
<p>在上述实现中，我们将各种菜系的餐具和这个菜系绑定在了一起，而厨师和餐具之间是有联系的，我们通过不同的工厂对象，获取了一系列相关联的对象集合。</p>
<h3 id="角色对应-2"><a href="#角色对应-2" class="headerlink" title="角色对应"></a>角色对应</h3><p>抽象工厂模式与工厂方法模式的角色基本相同。唯一不同之处在于，具体产品角色不再是由一个具体对象担任，而是由一系列的对象。由具体工厂产出的对象都可以称之为具体产品对象</p>
<h3 id="优缺点分析-2"><a href="#优缺点分析-2" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><ul>
<li><p>优点</p>
<ul>
<li><p>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。<br>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</p>
</li>
<li><p>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</p>
</li>
<li><p>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</p>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们借用一个故事来说明了工厂模式的演化和进阶，但是对于工厂模式而言，需要根据场景的不同而去选择最合适的一种，不一定一味的追求最复杂的。最好的软件设计不是具有多复杂的系统设计，而是在满足需求的情况下，尽可能的降低系统的复杂度。</p>
<p>工厂模式也是会有退化的。当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式之抽象</title>
    <url>/2019/04/10/%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于抽象而言，往往用来表征对问题分析设计中得出的抽象概念，是一系列看上去不相同，但却具有相同本质的抽象。抽象是针对一系列具象来说的，对于具体业务场景的不同，我们对同一现实物体会具有不同的抽象结果表现。比如男人和女人，我们抽象出的抽象类可能是Human，而对于男人和狗，我们抽象出来的则可能会是Animal。</p>
<p>在面向对象的编程思想中，所有具体的对象都是通过类来实现的。但是反过来，并不是所有的类都是用来描绘对象的，一般我们会把这种类称之为抽象类。我们习惯把现实生活中具有共同特征的事物进行抽象，将其称之为类。而抽象类，则更像是将具有共同特征的类进行抽象。</p>
<a id="more"></a>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>抽象是多态性的一种体现。</p>
<p>假设我们会有一个场景：设计俄罗斯方块游戏。</p>
<p>在俄罗斯方块的游戏中，方块是具有翻转动作的，而方块有六种形态，六种形态的翻转动作都不一致。对于“田”字型方块，无论怎么翻转都是一样的；而对于“一”字型方块，只会具有两种的翻转动作，即“一”和“丨”。我们以这两种为例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareBlock</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"keep still!"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"appear"</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disappear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"disappear"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"down"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OblongBlock</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"trun!"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"appear"</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disappear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"disappear"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"down"</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码实现了“田”字型方块的类和“一”字型方块的类，当我们点击方块的时候，会触发当前方块的turn行为，而当方块被铺满一格的时候，会触发他们的disappear的行为。当我们仔细观察的时候发现，这两个方块类是具有很多相同的动作的，比如disappear、appear以及down，不论是哪种方块，这些动作都完全一样。</p>
<p>这么做的是可行的，代码也是能够正常工作的。但是问题在于，有过多的重复性代码。而且如果disappear的行为变化了该去如何处理，找到所有方块的disappear方法，然后一个一个进行修改么？</p>
<p>当然，你也可以这么去实现它。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.attr == <span class="string">"Square"</span>：</span><br><span class="line">        	print(<span class="string">"keep still!"</span>)</span><br><span class="line">        <span class="keyword">elif</span> self.attr == <span class="string">"oblong"</span>:</span><br><span class="line">            print(<span class="string">"trun!"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"appear"</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disappear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"disappear"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"down"</span>)</span><br></pre></td></tr></table></figure>

<p>将上述代码改写了一下，代码量减少了很多，而且如果共性方法需要修改，只需要修改一次就行了。但是是如果说后续加了其他的方块，他们的翻转动作又不一样，我们将不得不修改Block的turn方法来满足需求。我们之前说过，设计原则中很重要的一条是开放封闭原则，即对功能扩展开放，而对修改封闭。这样的做法会让代码看起来乱糟糟的一团，而且不利于后期的扩展和维护。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">appear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"appear"</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disappear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"disappear"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"down"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareBlock</span><span class="params">(BaseBlock)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"keep still!"</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OblongBlock</span><span class="params">(Baseblock)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"trun!"</span>)</span><br></pre></td></tr></table></figure>

<p>我们利用面向对象的多态性，将所有方块都具有的方法都抽象出来，放在Block中，然后对于每个方块所不同的行为，即turn，则在子类中去具体的实现。这样一来，当我们需要增加方块的种类的视乎，只需要重新创建子类，实现turn方法，并不需要去修改之前的代码。并且增强了代码的复用性，子类实现越多，代码复用性越强。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>到目前为止，我们还没有去引出本文的主题—抽象类。抽象类是不能够被实例化的存在，而我们上面的Block是可以被实例化的，它只是作为一个基类的存在，而不具备抽象类的特性。</p>
<p>那为什么要去实现抽象类呢？好像上面的代码也不会出问题，既符合设计原则，也满足业务场景需要。但是在实际开发过程中，一个业务的具体实现，往往是由多人协作完成的，程序员所书写的代码，不仅仅是为了实现业务，而且要能在关键的地方给别人一目了然的感觉。尤其是当需要完成的是下层接口供上层调用的时候，这种特性就更加明显，需要给别人以明显的提示：这是一个基类，请不要去实例化它，或者在当别人试图实例化基类的时候，明确的抛出异常。</p>
<p>如果说你没有在任何地方声明Block是作为基类存在的话，别人可能会误以为你在某个地方具有它的实例，但是当别人找遍了你的代码却没找到的时候，一定会对你进行问候。甚至有可能出现某种情况误将基类实现去替代子类的作用，这样当执行到turn的之后，代码将直接跳过，而不得不花费成倍的事件去定位这个问题的原因。</p>
<p>反而言之，如果你将Block作为抽象类存在。当我看到方块类是抽象的，我会很关心它的抽象方法。我知道它的子类一定会重写它，而且，我会去找到抽象类的引用。它一定会有多态性的体现。</p>
<h2 id="Python中的抽象类"><a href="#Python中的抽象类" class="headerlink" title="Python中的抽象类"></a>Python中的抽象类</h2><p>由于Python是一门动态类型语言，我们想要实现抽象类的方法有很多。但是如果你想定义一个抽象类，并且通过执行类型检查来查看子类是否实现类抽象方法，可以尝试使用abc模块。</p>
<blockquote>
<p>abc 即 Abstract Base Classes</p>
</blockquote>
<h3 id="ABCMeta元类"><a href="#ABCMeta元类" class="headerlink" title="ABCMeta元类"></a>ABCMeta元类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IStream</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, maxbytes=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">a = IStream()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TypeError: Can<span class="string">'t instantiate abstract class IStream with abstract methods read, write</span></span><br></pre></td></tr></table></figure>

<p>当定义一个类的时候，指定它的元类为ABCMeta，这个类就会被定为抽象类，并且确保它不会被实例化。</p>
<h3 id="abstractmethod抽象方法"><a href="#abstractmethod抽象方法" class="headerlink" title="abstractmethod抽象方法"></a>abstractmethod抽象方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IStream</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, maxbytes=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketStream</span><span class="params">(IStream)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>当抽象类中的方法被abstractmethod所装饰之后，子类如果不实现被装饰的方法，在Python运行的时候就会抛出异常告诉你抽象类的子类需要实现抽象方法</p>
<p>在cookbook的介绍中，他们不是很推荐过多的使用abc模块进行类型检查，原因是</p>
<blockquote>
<p>尽管ABCs可以让我们很方便的做类型检查，但是我们在代码中最好不要过多的使用它。 因为Python的本质是一门动态编程语言，其目的就是给你更多灵活性， 强制类型检查或让你代码变得更复杂，这样做无异于舍本求末。</p>
</blockquote>
<h3 id="另一种抽象类的实现"><a href="#另一种抽象类的实现" class="headerlink" title="另一种抽象类的实现"></a>另一种抽象类的实现</h3><p>基于Python的灵活性，我们可以使用其他的方式来实现抽象类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">appear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"appear"</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disappear</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"disappear"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"down"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareBlock</span><span class="params">(BaseBlock)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"keep still!"</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OblongBlock</span><span class="params">(Baseblock)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"trun!"</span>)</span><br></pre></td></tr></table></figure>

<p>只需要在turn中抛出指定异常</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于抽象类而言，我个人是认为将类的共性方法抽象出来以达到复用的目的。Python的语法非常灵活，不像是Java或者C++的那种静态类型，定义抽象类会使用关键字。这种灵活性好处在于，对于Python的入门难度很低，但是坏处在于，如果想达到一定的高度或者对coding有本质上的理解，可能也会有一定的阻碍。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工具网站</title>
    <url>/2019/08/31/%E6%94%B6%E5%BD%95%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h3 id="办公聚合工具"><a href="#办公聚合工具" class="headerlink" title="办公聚合工具"></a>办公聚合工具</h3><p>UZER : <a href="http://uzer.me/" target="_blank" rel="noopener">http://uzer.me</a></p>
<a id="more"></a>
<h3 id="格式转换神器"><a href="#格式转换神器" class="headerlink" title="格式转换神器"></a>格式转换神器</h3><p>CONVERTIO : <a href="https://convertio.co/zh/" target="_blank" rel="noopener">https://convertio.co/zh/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
